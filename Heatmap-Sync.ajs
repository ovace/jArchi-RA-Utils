/*
 * Heatmap-Sync Enhanced (Modularized, Fully Documented, with Header Fallback,
 * Progress Reporting, Grouping Extraction, View-Membership, and Blank-Row Filtering)
 * Heatmap-Sync Enhanced (Modularized, Fully Documented, with View-Membership and Robust CSV Helpers)
 */

(function() {
  // Initialize console
  console.clear();
  console.show();

  // Load shared libraries  
  const libPath = __DIR__ + 'lib\\';
  console.log("libPath: " + libPath);
  const envPath = __DIR__+".env";
  console.log("envPath: " + envPath);
  // any of these now work
  load(libPath + 'loadEnv.ajs').loadEnv(envPath);
  // const { loadEnv } = require(libPath + 'loadEnv.ajs');
  // loadEnv(envPath);

  const { log } = load(libPath + 'logger.ajs');
  // require(libPath +'logger.ajs').log.info("â€¦");
  log.info("global log works");

  const utils  = require(libPath + 'common_utils.ajs');
  
  const XLSX   = require(libPath + 'xlsx.full.min.js');

  // â”€â”€ Module-level caches for generateExtRef â”€â”€
    var _extRef_dictCache     = null;
    var _extRef_countMapCache = null;
    var _extRef_lastKey       = null;


  const { 
    assignRowUUIDs,
    buildCsvLine,   
    buildHeader,
    buildProperties,
    collectColumnValues,
    collectPropValues,
    conceptRelationshipMap,
    createSubfolderUnderParent,
    escapeFolderName,
    escapeString,
    exportToExcel,
    findFolderByName_selector,
    findFoldersByName_filter,
    findSubFolderByName,
    findSubfoldersUnderParent,
    findSubfoldersUnderParentObject,
    formatForCSV,
    getActiveModel,
    getElementViews,
    getImmediateChildFolders,
    getOrCreateSubfolder,
    getRootFolders,
    getRowValue,
    getSubfolders,
    loadSheetJS,
    mergeDynamicProps,
    normalize,
    normalizeFolderName,
    promptForFile,
    readCSV,
    readFileBase64,
    toJsArray,    
    unescapeString,
    validateColumns,
    writeCsv,
  } = utils;

//   const { log, 
//           debug, 
//           warn, 
//           error 
//         } = logger;

  // Configuration  

  /** @typedef {{
   *    sheetName: string,
   *    excelFilters: Array<Object>,
   *    csvFilters: Array<Object>,
   *    sheetjsPath: string,
   *    requiredColumns: string[],
   *    baseOutputCols: string[],
   *    flagCols: string[],
   *    extraCols: string[],
   *    relationshipTypes: string[],
   *    levelMap: Object<string,{col:string}>,
   *    debug: boolean
   * }} Config
   */
  const config = {
    debug: true,
    readWorkbook: true,
    getConceptDetails: true,
    getRelarionshipMap: true,    

    sheetjsPath:  __DIR__ + '/lib/xlsx.full.min.js',    
    
    excelFilters: [{ name: 'Excel Workbook', extensions: ['xlsm','xlsx'] }],
    sheetName: 'Function-HeatMap-Final',

    csvFilters:   [{ name: 'CSV File',      extensions: ['csv'] }],
    
    requiredColumns: ['_id','ABB Name','Functional composition','Description','Pri Domain'],
    baseOutputCols:  ['_id','ABB Name','Functional composition', 'ext-Name', 'Description','Pri Domain'],
    flagCols:        ['Taxonomy Classification','Level','nameMatch','descMatch','modelOnly'],
    extraCols:       ['ID','Type','Grouped_under','inView'],

    extHeadersMap : {
        extCol: 'ABB Name',
        refCol: "Functional composition",
        outCol: 'ext-Name'
        },
    relationshipTypes: [
      'association-relationship',
      'aggregation-relationship',
      'composition-relationship'
    ],
    modelProperties: [
      'Level',
      'Taxonomy Classification',
      'Version',
      'Owner',
      'Name',
      'StandardSolutionExample',
      'ExampleUse',      
    ],
    uuidCols: [
      'Pri Domain',
      'ext-Name',
      'ABB Name'      
    ],
    /**
     * supplementProperties: List of computed or derived properties for export/metadata.
     * Each entry provides a key (column name) and a function taking (el, ctx).
     */
    supplementProperties : [
        {
            key: "ID",
            fn: function(el) { return el && el.id ? el.id : ""; }
        },
        {
            key: "Type",
            fn: function(el) { return el && el.type ? el.type : ""; }
        },
        {
            key: "Grouped_under",
            fn: function(el, ctx) { return el ? ctx.getGrouping(el, ctx.relTypeIds) : ""; }
        },
        {
            key: "inView",
            fn: function(el, ctx) { return el ? ctx.getElementViews(el) : "Orphan"; }
        }
        // Add further computed fields here as needed
    ],
    levelMap: {
      '0': { col: 'ABB Name' },
      '1': { col: 'ABB Name' },
      '2': { col: 'Functional composition' }
    },    
    // CSV Options
    delimiter: ',',
    newline: '\n',
    escapeFormulae: true  
  };

  const relTypeIds = config.relationshipTypes;
  
  /**
   * Determine grouping for an element via configured relationship types.
   * @param {Object} element â€“ Archi element proxy
   * @param {string[]} relTypes
   * @returns {string} grouping name, relationship type, or ''
   */
  function getGrouping(element, relTypes) {
    log.debug('getGrouping() for ' + element.id + '/' + element.name);
    for (let type of relTypes) {
      const ofType   = $('relationship').filter(r => r.type.toLowerCase() === type).toArray();
      const relevant = ofType.filter(r => r.source.id === element.id || r.target.id === element.id);
      log.debug('type=' + type + ', total=' + ofType.length + ', relevant=' + relevant.length);
      if (relevant.length) {
        for (let r of relevant) {
          const other = (r.source.id === element.id ? r.target : r.source);
          if (other.type.toLowerCase() === 'grouping') {
            log.debug('grouping found: ' + other.name);
            return other.name;
          }
        }
        log.debug(' no grouping element; return type ' + type);
        return type;
      }
    }
    return '';
  }

/**
 * Process sheet rows into an array of record objects.
 * Uses buildProperties() for model element data injection.
 *
 * @param {Array|Object}  data       Raw sheet data: 
 *                                   - array of arrays (sheet_to_json header:1) 
 *                                   - array of objects (sheet_to_json header:keys) 
 *                                   - or a single object.
 * @param {Function}      colIdxFn   Maps a column name to either an index (for arrays)
 *                                   or a property key (for objects).
 * @param {Object}        matchedIds Accumulator; we set matchedIds[el.id] = true when we find a model element.
 * @param {string[]}      propKeys   List of all property keys to include in each output record.
 *
 * @returns {Object[]} An array of â€œrecordâ€ objects keyed by propKeys.
 */
function processSpreadsheetRows(data, colIdxFn, matchedIds, propKeys) {
    // 1. Validate inputs
    if (typeof colIdxFn !== 'function') {
        throw new TypeError('colIdxFn must be a function');
    }
    if (!Array.isArray(propKeys)) {
        throw new TypeError('propKeys must be an array of strings');
    }

    log.debug('propKeys:', JSON.stringify(propKeys));
    log.debug('matchedIds (before):', JSON.stringify(matchedIds));

    // 2. Normalize into [{ row, sheetRow }, â€¦]
    let normalizedData = [];

    if (Array.isArray(data)) {
        if (data.length > 0 && typeof data[0] === 'object' && !Array.isArray(data[0])) {
            // Already an array of objects
            normalizedData = data.map((rowObj, i) => ({
                row:      rowObj,
                sheetRow: i + 1            // adjust if you have header/title rows
            }));
        }
        else {
            // Array of arrays â†’ drop first two (title + header), then wrap
            normalizedData = data
              .slice(2)
              .map((rowArr, i) => ({
                  row:      rowArr,
                  sheetRow: i + 3          // if slice(2), the first real data row is sheet-row #3
              }));
        }
    }
    else if (data !== null && typeof data === 'object') {
        // Single object â†’ wrap into one-entry array
        normalizedData = [{ row: data, sheetRow: 1 }];
    }
    else {
        throw new TypeError(`Unsupported data type: ${typeof data}`);
    }

    // 3. Debugâ€“print first 3 entries
    normalizedData.slice(0, 3).forEach(({ row, sheetRow }, idx) => {
        log.debug(
            `Sample #${idx} (sheetRow=${sheetRow}): ` +
            JSON.stringify(row, null, 2)
        );
    });

    log.info(`Processing ${normalizedData.length} spreadsheet rowsâ€¦`);

    // 4. Prepare context for buildProperties
    const ctx = {
        getGrouping:    getGrouping,
        getElementViews: getElementViews,
        relTypeIds:     relTypeIds
    };

    // 5. Core loop
    const output = [];
    normalizedData.forEach(({ row, sheetRow }, idx) => {
        log.debug(`[${idx + 1}/${normalizedData.length}] sheetRow=${sheetRow}`);

        // 5.1 Lookup your Archi element by â€œFunctional compositionâ€
        const fcKey   = 'Functional composition';
        const fcIndex = colIdxFn(fcKey);
        const fcRaw   = (row[fcIndex] || '').toString();
        const fcNorm  = normalize(fcRaw);
        const el      = $('element')
                          .filter(e => normalize(e.name) === fcNorm)
                          .first();

        // 5.2 Build spreadsheetProps
        const spreadsheetProps = {};
        propKeys.forEach(k => { spreadsheetProps[k] = ''; });
        config.baseOutputCols.forEach(col => {
            const idxKey = colIdxFn(col);
            spreadsheetProps[col] = row[idxKey] || '';
        });
        spreadsheetProps.nameMatch  = '0';
        spreadsheetProps.descMatch  = '0';
        spreadsheetProps.modelOnly  = '0';

        // 5.3 If we found a model element, pull in its properties
        let modelProps = {};
        if (el) {
            spreadsheetProps.nameMatch = '1';
            const docNorm  = normalize(el.documentation || '');
            const descIdx  = colIdxFn('Description');
            const descNorm = normalize((row[descIdx] || '').toString());
            if (docNorm === descNorm) {
                spreadsheetProps.descMatch = '1';
            }
            matchedIds[el.id] = true;
            modelProps = buildProperties(
                el,
                config.modelProperties,
                config.supplementProperties,
                ctx
            );
        }
        else {
            // mark orphans
            config.supplementProperties.forEach(supp => {
                if (supp.key === 'inView') {
                    modelProps[supp.key] = 'Orphan';
                }
            });
        }

        // 5.4 (Optional) collect dynamic values
        let dynVals = {};
        // dynVals = collectPropValues(el, propKeys);

        // 5.5 Merge priority: spreadsheet < model < dyn
        const rec = {};
        propKeys.forEach(k => { rec[k] = ''; });
        mergeDynamicProps(rec, spreadsheetProps, propKeys);
        mergeDynamicProps(rec, modelProps,       propKeys);
        mergeDynamicProps(rec, dynVals,          propKeys, true);

        // 5.6 Force spreadsheet override on these columns
        ['Taxonomy Classification','Level'].forEach(col => {
            if (col in rec) {
                const idxKey = colIdxFn(col);
                rec[col] = (row[idxKey] || rec[col] || '').toString();
            }
        });

        output.push(rec);
    });

    return output;
}


  /**
   * Generate an â€œexternal â†” referenceâ€ code for each row in a data array,
   * mirroring VBAâ€™s GenerateExtRef but in-memory and batched.
   *
   * @param {Object[]} data
   *    Array of row-objects keyed by column header.
   * @param {{extCol:string, refCol:string, outCol:string}} headersMap
   *    Map of your 3 columns from config.
   * 
   * @returns {Object[]}
   *    Same data array, with each row[outCol] populated.
   */
  function generateExtRef(data, headersMap) {
    const { extCol, refCol, outCol } = headersMap;
    const cacheKey = extCol + '|' + refCol;

    // Moduleâ€level caches on outer scope
    if (!_extRef_dictCache || cacheKey !== _extRef_lastKey) {
      log.debug(`ðŸ”„ Rebuilding extRef cache for ${cacheKey}`);
      _extRef_dictCache    = {};
      _extRef_countMapCache = {};

      log.debug("data length: " + data.length);

      // 1) Initial code assignment
      data.forEach(row => {
        const extKey = headersMap.extCol.trim();
        let extVal = (row[extCol]||'').toString().trim();
        log.debug(`Column: ${extCol} Row: ${row[extCol]} extVal=${extVal} cache val=${_extRef_dictCache[extVal]}`);

        if (extVal && !_extRef_dictCache[extVal]) {
          const parts = extVal.split(/\s+/);
          let code = parts.length === 1
            ? parts[0].substring(0,3)
            : parts.map(p => p.charAt(0)).join('');
          code = utils.toJsArray([code]).join('').replace(/[^A-Za-z0-9]/g,'');
          _extRef_dictCache[extVal] = code;
          log.debug(`    Map: ${extVal} â†’ ${code}`);
        }
      });

      // 2) Count duplicates
      Object.values(_extRef_dictCache)
        .forEach(code => _extRef_countMapCache[code] = (_extRef_countMapCache[code]||0) + 1);

      // 3) Upgrade duplicates to 2-chars/word
      log.debug('    Checking duplicatesâ€¦');
      Object.keys(_extRef_dictCache).forEach(key => {
        const code = _extRef_dictCache[key];
        log.debug('code: ' + code + ' Cache value: ' + _extRef_countMapCache[code]);
        if (_extRef_countMapCache[code] > 1) {
          const parts = key.split(/\s+/);
          let newCode = parts.map(p => p.length>1 ? p.substring(0,2) : p.charAt(0)).join('');
          newCode = newCode.replace(/[^A-Za-z0-9]/g,'');
          _extRef_dictCache[key] = newCode;
          log.debug(`      Upgraded: ${key} â†’ ${newCode}`);
        }
      });

      _extRef_lastKey = cacheKey;
    }
    else 
      log.debug(`âœ… Using cached extRef map for ${cacheKey}`);
    

    // 4) Compute & assign result per row
    data.forEach((row, idx) => {
      const extVal = (row[extCol]||'').toString().trim();
      const refVal = (row[refCol]||'').toString().trim();
      
      log.debug(`Row ${idx} extVal='${extVal}' refVal='${refVal}'`);
      

      const code = _extRef_dictCache[extVal] || '';
      let result = '';
      if (extVal && extVal.toLowerCase() === refVal.toLowerCase()) {
        result = extVal;
      }
      else if (!code && !refVal) {
        result = '';
      }
      else if (!refVal) {
        result = code;
      }
      else if (!code) {
        result = refVal;
      }
      else if (code.replace(/\s+/g,'').toLowerCase() === refVal.replace(/\s+/g,'').toLowerCase()) {
        result = refVal;
      }
      else {
        result = `${code}-${refVal}`;
      }

      log.debug(`â†’ result: ${result}`);
      row[outCol] = result;
    });

    return data;
  }

  //â€” End of new generateExtRef helper â€”â€”


/**
 * Process model-only elements (not matched in spreadsheet).
 * Returns array of records, one per unmatched model element.
 */
function processModelOnly(matchedIds, propKeys) {
    log.info('Processing model-only elements...');
    let output = [];
    let count = 0;
    const ctx = {
        getGrouping: getGrouping,
        getElementViews: getElementViews,
        relTypeIds: relTypeIds
    };

    toJsArray($('element').toArray())
        .filter(e => !matchedIds[e.id])
        .forEach((el, idx) => {
            count++;
            log.debug(`[ ${count}] Model-only element ${el.id}`);

            // 1. Spreadsheet props: modelOnly, nameMatch, etc.
            let spreadsheetProps = {};
            propKeys.forEach(key => { spreadsheetProps[key] = ''; });
            spreadsheetProps['modelOnly'] = '1';
            spreadsheetProps['nameMatch'] = '0';
            spreadsheetProps['descMatch'] = '0';

            // 2. Model props (from buildProperties)
            let modelProps = buildProperties(
                el,
                config.modelProperties,
                config.supplementProperties,
                ctx
            );

            // 3. Dynamic values (if you use them; optional)
            let dynVals = collectPropValues(el, propKeys);

            // 4. Chain merges (spreadsheet < model < dynVals)
            let rec = {};
            propKeys.forEach(key => { rec[key] = ''; });
            mergeDynamicProps(rec, spreadsheetProps, propKeys);
            mergeDynamicProps(rec, modelProps, propKeys);
            mergeDynamicProps(rec, dynVals, propKeys, true);

            // Place the name in the correct column, clear others
            const lvl = el.prop('Level') || '0';
            const mapEntry = config.levelMap[lvl] || config.levelMap['0'];
            const targetCol = mapEntry.col;
            if ('ABB Name' in rec) rec['ABB Name'] = '';
            if ('Functional composition' in rec) rec['Functional composition'] = '';
            rec[targetCol] = el.name;
            if ('Description' in rec)   rec['Description']   = el.documentation || '';

            output.push(rec);
        });

    return output;
}

/** Main entry point */
/**
 * Main entry point for Heatmap-Sync.
 * Loads and processes input Excel, writes CSV output, and (optionally) exports model relationship map to Excel.
 */
function main() {
    try {
        
        var model = getActiveModel();
        if (!model) {
            log.warn('No active model. Aborting.');
            return;
        }

       
          log.debug('Diagnostic information...');

          log.debug('engineName :' +$.process.engine);
          log.debug('platform: ' + $.process.platform );
          log.debug('archi Name: ' + $.process.archiname );
          log.debug(' archi version : ' + $.process.release.archiVersion);
          log.debug(' jArchi name: ' + $.process.release.jArchiName);
          log.debug(' version : ' + $.process.release.jArchiVersion);

          log.debug('Active model: ' + model.name);
          log.debug('Element count: ' + $('element').size());
          log.debug('Relationship count: ' + $('relationship').size());
          log.debug('Property count: ' + $('property').size());

          // $('element').forEach(function(e) {
          //     log.debug('---------------------------------------------');
          //     log.debug('Element: ' + e.name + ' | type: ' + e.type + ' | id: ' + e.id);

          //     // Outgoing relationships
          //     var outRels = e.outRels();
          //     log.debug('Number of outRels: ' + outRels.length);
          //     outRels.forEach(function(rel) {
          //         var target = rel.target;
          //         log.debug('  Outgoing rel type: ' + rel.type +
          //             ' â†’ target element: ' +
          //             (target ? (target.name + ' (' + target.type + ')') : '[no target]'));
          //     });

          //     // Incoming relationships
          //     var inRels = e.inRels();
          //     log.debug('Number of inRels: ' + inRels.length);
          //     inRels.forEach(function(rel) {
          //         var source = rel.source;
          //         log.debug('  Incoming rel type: ' + rel.type +
          //             ' â† source element: ' +
          //             (source ? (source.name + ' (' + source.type + ')') : '[no source]'));
          //     });
          // });
          // $('element').each(function(e) {
          //     var outCount = 0;
          //     $('relationship').each(function(rel) {
          //         if (rel.source && rel.source.id === e.id) {
          //             outCount++;
          //             // Gather info for source, relationship, target
          //             var sourceName = e.name || '';
          //             var sourceType = e.type || '';
          //             var sourceId   = e.id || '';
          //             var relType    = rel.type || '';
          //             var relId      = rel.id || '';
          //             var targetName = rel.target ? (rel.target.name || '') : '';
          //             var targetType = rel.target ? (rel.target.type || '') : '';
          //             var targetId   = rel.target ? (rel.target.id   || '') : '';

          //             log.debug(
          //                 'Source Name: ' + sourceName +
          //                 ' | Source Type: ' + sourceType +
          //                 ' | Source ID: ' + sourceId +
          //                 ' | Relationship Type: ' + relType +
          //                 ' | Relationship ID: ' + relId +
          //                 ' | Target Name: ' + targetName +
          //                 ' | Target Type: ' + targetType +
          //                 ' | Target ID: ' + targetId
          //             );
          //         }
          //     });
          //     log.debug('Element: ' + e.name + ' | Outgoing relationships: ' + outCount);
          // });

        // 0. Validate config
        // validateConfig();

        if (config.getConceptDetails) {
            log.info('Starting Heatmap-Sync execution...');

              log.info('Starting read workbook '+ '...')
              // 1. Prompt for input and output files
              const excelPath = promptForFile('Select source Heatmap Excel Workbook', config.excelFilters, window.promptOpenFile);
              if (!excelPath) return;
              const csvPath = promptForFile('Heatmap output CSV File', config.csvFilters, window.promptSaveFile);
              if (!csvPath) return;
              log.debug('reading Excel from: ' + excelPath);
              // 2. Load Excel, read worksheet
              log.debug('Loading SheetJS from: ' + config.sheetjsPath);
              const wb = XLSX.read(readFileBase64(excelPath), { type: 'base64' });
              const sheet = wb.Sheets[config.sheetName];
              if (!sheet) throw new Error('Sheet "' + config.sheetName + '" not found');

              // â˜… OPTION 2: object-based loader â˜…
              // 2.1 Grab & trim the raw header row (Excel row 1)
              // 1) pull every row as an array...
              const sheetRows = XLSX.utils.sheet_to_json(sheet, { header: 1, raw: false });

              // 2) now grab the *second* row (index 1) as your real header row
              const rawHeaders = sheetRows[1].map(h => h.toString().trim());
              log.debug('Trimmed headers (from row 2):', rawHeaders);              

              // 2.2 Now read the rest of the rows into objects keyed by those headers
              let data = XLSX.utils.sheet_to_json(sheet, {
                header: rawHeaders,
                range:    2,     // skip header row
                defval:   '',    // empty strings for blank cells
                raw:      false
              });              
              log.debug(`read rows data: ${data.length} from sheet: ${config.sheetName} in workbook: ${excelPath}`);
              
              // 3. Generate ext Name  extensions ext-Name
              data = generateExtRef(data, config.extHeadersMap)
              log.debug(`ext data: ${data.length} headers: ${JSON.stringify(config.extHeadersMap)}` )
              
              // 3. Validate headers (object-based `data`)
              const headersRow = Object
                .keys(data[0])
                .map(h => h.toString().trim());
              log.debug('headers with ext: ' + headersRow.join(', '));

              // (optional) make sure your extHeadersMap values are present
              const missing = Object
                .values(config.extHeadersMap)
                .filter(h => !headersRow.includes(h));
              if (missing.length) {
                throw new Error(
                  `Missing expected headers in sheet: ${missing.join(', ')}`
                );
              }
             
              let colIdx = c => headersRow.indexOf(c);
              validateColumns(colIdx, config.requiredColumns);
                        
            
              // 4. Prepare CSV output columns
              let propKeys = ['uid']
                  .concat(config.baseOutputCols)
                  .concat(config.flagCols)
                  .concat(config.extraCols);

              config.modelProperties.forEach(key => {
                  if (!propKeys.includes(key)) propKeys.push(key);
              });

              config.supplementProperties.forEach(s => {
                  if (!propKeys.includes(s.key)) propKeys.push(s.key);
              });

              // 5. Process spreadsheet and model data
              let matchedIds = {};
              let allRows = [];
              allRows = allRows.concat(processSpreadsheetRows(data, colIdx, matchedIds, propKeys));
              allRows = allRows.concat(processModelOnly(matchedIds, propKeys));
          

            assignRowUUIDs(allRows, config.uuidCols, 'uid');

            // 6. Write output CSV
            log.info('Exporting ' + allRows.length + ' rows...');
            log.info(`propKeys: ${propKeys}`);
            let csv = buildHeader(propKeys) + '\n';
            allRows.forEach(rec => {
                csv += buildCsvLine(rec, propKeys) + '\n';
            });
            writeCsv(csv, csvPath);

            window.alert('Export complete: ' + csvPath);
        }

        if (config.getRelarionshipMap) {

          // 7. export concept relationship map to Excel
          if (window.confirm('Export a model relationship map to Excel?')) {
              log.info('[main] User requested relationship map Excel export.');
              // Compose relationship map from all model elements
              const elements = toJsArray($('element').toArray());
              const mapRows = conceptRelationshipMap(elements, "out");
              exportToExcel(mapRows, 'Relationships', 'Save Relationship Map Excel');
          } else {
              log.info('[main] Relationship map export skipped by user.');
          }
        }

        log.info('Heatmap-Sync execution complete.');
    }
    catch (err) {
        log.error('Error: ' + err);
        window.alert('Script failed: ' + (err && err.message ? err.message : err));
    }
}


    log.info('Heatmap-Sync script started.');    
    main();
})();

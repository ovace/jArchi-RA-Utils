/*
 * Heatmap-Sync Enhanced (Modularized, Fully Documented, with Header Fallback,
 * Progress Reporting, Grouping Extraction, View-Membership, and Blank-Row Filtering)
 * Heatmap-Sync Enhanced (Modularized, Fully Documented, with View-Membership and Robust CSV Helpers)
 */

(function() {
  // Initialize console
  console.clear();
  console.show();

  // Load shared libraries
  const libPath = __DIR__ + 'lib\\';
  const utils  = require(libPath + 'common_utils.ajs');
  const logger = require(libPath + 'logger.ajs');
  const XLSX   = require(libPath + 'xlsx.full.min.js');

  const { 
    assignRowUUIDs,
    buildCsvLine,   
    buildHeader,
    buildProperties,
    collectColumnValues,
    collectPropValues,
    createSubfolderUnderParent,
    escapeFolderName,
    escapeString,
    findFolderByName_selector,
    findFoldersByName_filter,
    findSubFolderByName,
    findSubfoldersUnderParent,
    findSubfoldersUnderParentObject,
    formatForCSV,
    getActiveModel,
    getElementViews,
    getImmediateChildFolders,
    getOrCreateSubfolder,
    getRootFolders,
    getRowValue,
    getSubfolders,
    loadSheetJS,
    mergeDynamicProps,
    normalize,
    normalizeFolderName,
    promptForFile,
    readCSV,
    readFileBase64,
    toJsArray,    
    unescapeString,
    validateColumns,
    writeCsv,
  } = utils;

  const { log, 
          debug, 
          warn, 
          error 
        } = logger;

  // Configuration  

  /** @typedef {{
   *    sheetName: string,
   *    excelFilters: Array<Object>,
   *    csvFilters: Array<Object>,
   *    sheetjsPath: string,
   *    requiredColumns: string[],
   *    baseOutputCols: string[],
   *    flagCols: string[],
   *    extraCols: string[],
   *    relationshipTypes: string[],
   *    levelMap: Object<string,{col:string}>,
   *    debug: boolean
   * }} Config
   */
  const config = {
    debug: false,
    sheetjsPath:  __DIR__ + '/lib/xlsx.full.min.js',
    
    heatMapFilePromptTitle: 'Select Heatmap Excel Workbook',
    excelFilters: [{ name: 'Excel Workbook', extensions: ['xlsm','xlsx'] }],
    sheetName: 'Function-HeatMap-Final',

    csvFilePromptTitle:   'Select Heatmap CSV File',
    csvFilters:   [{ name: 'CSV File',      extensions: ['csv'] }],
    
    requiredColumns: ['_id','ABB Name','Functional composition','Description','Pri Domain'],
    baseOutputCols:  ['_id','ABB Name','Functional composition','Description','Pri Domain'],
    flagCols:        ['Taxonomy Classification','Level','nameMatch','descMatch','modelOnly'],
    extraCols:       ['ID','Type','Grouped_under','inView'],
    relationshipTypes: [
      'association-relationship',
      'aggregation-relationship',
      'composition-relationship'
    ],
    modelProperties: [
      'Level',
      'Taxonomy Classification',
      'Version',
      'Owner',
      'Name',
      'StandardSolutionExample',
      'ExampleUse',
      'Type',
    ],
    uuidCols: [
      'Pri Domain',
      'Functional composition',
      'ABB Name'      
    ],
    /**
     * supplementProperties: List of computed or derived properties for export/metadata.
     * Each entry provides a key (column name) and a function taking (el, ctx).
     */
    supplementProperties : [
        {
            key: "ID",
            fn: function(el) { return el && el.id ? el.id : ""; }
        },
        {
            key: "Grouped_under",
            fn: function(el, ctx) { return el ? ctx.getGrouping(el, ctx.relTypeIds) : ""; }
        },
        {
            key: "inView",
            fn: function(el, ctx) { return el ? ctx.getElementViews(el) : "Orphan"; }
        }
        // Add further computed fields here as needed
    ],
    levelMap: {
      '0': { col: 'ABB Name' },
      '1': { col: 'ABB Name' },
      '2': { col: 'Functional composition' }
    },    
    // CSV Options
    delimiter: ',',
    newline: '\n',
    escapeFormulae: true  
  };

  const relTypeIds = config.relationshipTypes;
  
  /**
   * Determine grouping for an element via configured relationship types.
   * @param {Object} element â€“ Archi element proxy
   * @param {string[]} relTypes
   * @returns {string} grouping name, relationship type, or ''
   */
  function getGrouping(element, relTypes) {
    if (config.debug) debug('[DEBUG] getGrouping() for ' + element.id + '/' + element.name);
    for (let type of relTypes) {
      const ofType   = $('relationship').filter(r => r.type.toLowerCase() === type).toArray();
      const relevant = ofType.filter(r => r.source.id === element.id || r.target.id === element.id);
      if (config.debug) debug('[DEBUG] - type=' + type + ', total=' + ofType.length + ', relevant=' + relevant.length);
      if (relevant.length) {
        for (let r of relevant) {
          const other = (r.source.id === element.id ? r.target : r.source);
          if (other.type.toLowerCase() === 'grouping') {
            if (config.debug) debug('[DEBUG] - grouping found: ' + other.name);
            return other.name;
          }
        }
        if (config.debug) debug('[DEBUG] - no grouping element; return type ' + type);
        return type;
      }
    }
    return '';
  }

  /**
 * Process sheet rows into an array of record objects.
 * Uses buildProperties() for model element data injection.
 */
function processSpreadsheetRows(rows, colIdxFn, matchedIds, propKeys) {
    const dataRows = rows.slice(2).map((r, i) => ({ row: r, sheetRow: i + 2 }));
    log('Processing ' + dataRows.length + ' spreadsheet rows...');

    const ctx = {
        getGrouping: getGrouping,
        getElementViews: getElementViews,
        relTypeIds: relTypeIds
    };

    let output = [];
    dataRows.forEach((entry, idx) => {
        log(' [' + (idx + 1) + '/' + dataRows.length + '] Sheet row ' + entry.sheetRow);

        const fc = normalize(entry.row[colIdxFn('Functional composition')] || '');
        const el = $('element').filter(e => normalize(e.name) === fc).first();

        // 1. Spreadsheet props
        let spreadsheetProps = {};
        propKeys.forEach(col => { spreadsheetProps[col] = ''; });
        config.baseOutputCols.forEach(col => {
            spreadsheetProps[col] = entry.row[colIdxFn(col)] || '';
        });
        spreadsheetProps['nameMatch'] = '0';
        spreadsheetProps['descMatch'] = '0';
        spreadsheetProps['modelOnly'] = '0';

        // 2. Model props
        let modelProps = {};
        if (el) {
            spreadsheetProps['nameMatch'] = '1';
            const docNorm = normalize(el.documentation || '');
            const descNorm = normalize(entry.row[colIdxFn('Description')] || '');
            if (docNorm === descNorm) spreadsheetProps['descMatch'] = '1';
            matchedIds[el.id] = true;
            modelProps = buildProperties(
                el,
                config.modelProperties,
                config.supplementProperties,
                ctx
            );
        } else {
            config.supplementProperties.forEach(supp => {
                if (supp.key === 'inView') modelProps[supp.key] = 'Orphan';
            });
        }

        // 3. Dynamic values (if you use them; optional)
        let dynVals = {};
        // dynVals = collectPropValues(el, propKeys); // if you use this

        // 4. Chain merges (spreadsheet < model < dynVals)
        let rec = {};
        propKeys.forEach(key => { rec[key] = ''; });
        mergeDynamicProps(rec, spreadsheetProps, propKeys);        // Lowest priority
        mergeDynamicProps(rec, modelProps, propKeys);              // Only if not already present
        mergeDynamicProps(rec, dynVals, propKeys, true);           // dynVals always wins if not empty

        // 5. Guarantee spreadsheet override for these (optional, as before)
        if ('Taxonomy Classification' in rec) {
            rec['Taxonomy Classification'] = entry.row[colIdxFn('Taxonomy Classification')] || rec['Taxonomy Classification'] || '';
        }
        if ('Level' in rec) {
            rec['Level'] = entry.row[colIdxFn('Level')] || rec['Level'] || '';
        }

        output.push(rec);
    });

    return output;
}

  /**
 * Process model-only elements (not matched in spreadsheet).
 * Returns array of records, one per unmatched model element.
 */
function processModelOnly(matchedIds, propKeys) {
    log('Processing model-only elements...');
    let output = [];
    let count = 0;
    const ctx = {
        getGrouping: getGrouping,
        getElementViews: getElementViews,
        relTypeIds: relTypeIds
    };

    toJsArray($('element').toArray())
        .filter(e => !matchedIds[e.id])
        .forEach((el, idx) => {
            count++;
            log(' [' + count + '] Model-only element ' + el.id);

            // 1. Spreadsheet props: modelOnly, nameMatch, etc.
            let spreadsheetProps = {};
            propKeys.forEach(key => { spreadsheetProps[key] = ''; });
            spreadsheetProps['modelOnly'] = '1';
            spreadsheetProps['nameMatch'] = '0';
            spreadsheetProps['descMatch'] = '0';

            // 2. Model props (from buildProperties)
            let modelProps = buildProperties(
                el,
                config.modelProperties,
                config.supplementProperties,
                ctx
            );

            // 3. Dynamic values (if you use them; optional)
            let dynVals = collectPropValues(el, propKeys);

            // 4. Chain merges (spreadsheet < model < dynVals)
            let rec = {};
            propKeys.forEach(key => { rec[key] = ''; });
            mergeDynamicProps(rec, spreadsheetProps, propKeys);
            mergeDynamicProps(rec, modelProps, propKeys);
            mergeDynamicProps(rec, dynVals, propKeys, true);

            // Place the name in the correct column, clear others
            const lvl = el.prop('Level') || '0';
            const mapEntry = config.levelMap[lvl] || config.levelMap['0'];
            const targetCol = mapEntry.col;
            if ('ABB Name' in rec) rec['ABB Name'] = '';
            if ('Functional composition' in rec) rec['Functional composition'] = '';
            rec[targetCol] = el.name;
            if ('Description' in rec)   rec['Description']   = el.documentation || '';

            output.push(rec);
        });

    return output;
}

/** Main entry point */
function main() {
    try {
        log('Starting Heatmap-Sync execution...');

        const excelPath = promptForFile(config.excelFilePromptTitle, config.excelFilters, window.promptOpenFile);
        if (!excelPath) return;
        const csvPath = promptForFile(config.csvFilePromptTitle, config.csvFilters, window.promptSaveFile);
        if (!csvPath) return;

        if (config.debug) debug('[DEBUG] Loading SheetJS from: ' + config.sheetjsPath);
        const wb = XLSX.read(readFileBase64(excelPath), { type: 'base64' });
        const sheet = wb.Sheets[config.sheetName];
        if (!sheet) throw new Error('Sheet "' + config.sheetName + '" not found');
        const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, raw: false });

        // Map headers
        const headersRow = rows[1].map(h => h.toString().trim());
        const colIdx = c => headersRow.indexOf(c);
        validateColumns(colIdx, config.requiredColumns);

        // Build full list of CSV columns
        let propKeys = ['uid']
            .concat(config.baseOutputCols)
            .concat(config.flagCols)
            .concat(config.extraCols);

        config.modelProperties.forEach(key => {
            if (!propKeys.includes(key)) propKeys.push(key);
        });

        config.supplementProperties.forEach(s => {
            if (!propKeys.includes(s.key)) propKeys.push(s.key);
        });

        // Build record arrays
        let matchedIds = {};
        let allRows = [];
        allRows = allRows.concat(processSpreadsheetRows(rows, colIdx, matchedIds, propKeys));
        allRows = allRows.concat(processModelOnly(matchedIds, propKeys));

        assignRowUUIDs(allRows, config.uuidCols, 'uid');

        log('Exporting ' + allRows.length + ' rows...');
        let csv = buildHeader(propKeys) + '\n';
        allRows.forEach(rec => {
            csv += buildCsvLine(rec, propKeys) + '\n';
        });

        writeCsv(csv, csvPath);

        log('Heatmap-Sync execution completed.');
        window.alert('Export complete: ' + csvPath);
    }
    catch (err) {
        error('Error: ' + err);
        window.alert('Script failed: ' + err.message);
    }
}

  log('Heatmap-Sync script started.');
  main();
})();

/**
 * ./lib/modelUtils.ajs
 *
 * Utility for extracting **all** Archi model elements into
 * plain JS entries for downstream processing.
 */

// Load shared libraries
  const libPath = __DIR__ ;  
  const envPath = __DIR__+"../.env";
  console.log("envPath: " + envPath); 
  const loadEnv = load(libPath + 'loadEnv.ajs').loadEnv(envPath);
  const { log } = require(libPath + 'logger.ajs'); 
  const dataUtils = require(libPath + 'data_utils.ajs');
  const common = require(libPath + 'common_utils.ajs');
  const { toJsArray } = common
  
  

/**
 * @typedef ModelEntry
 * @property {IElement} el        The raw Archi element
 * @property {Object}  row        Blank record initialized with propKeys
 * @property {number}  sheetRow   1-based index in this extracted list
 */

/**
 * @typedef ModelMap
 * @property {string}           conceptName          Output key for element.name
 * @property {string}           conceptType          Output key for element.type.name
 * @property {string}           conceptID            Output key for element.id
 * @property {string[]}         conceptProperties    Names of element properties to extract via el.prop()
 * @property {string[]}         relationshipTypes    Relationship-type names to gather outgoing targets
 * @property {Object<string,Function>} [others]
 *      Optional extra fields: key→fn(el) to compute additional values
 */

/**
 * Extracts raw data from every Archi element according to `modelMap`.
 *
 * @param {ModelMap} modelMap
 * @returns {Object[]} Array of objects, each with keys from `modelMap` (and `others`)
 * @throws {TypeError} on invalid inputs
 */
function getModelData(modelMap) {
  if (!dataUtils.isObject(modelMap)) {
    throw new TypeError('getModelData(): modelMap must be an object');
  }
  const {
    conceptName,
    conceptType,
    conceptID,
    conceptDocument,
    conceptProperties,
    relationshipTypes,
    others
  } = modelMap;
  // Validate required map fields
  if (typeof conceptName !== 'string' ||
      typeof conceptType !== 'string' ||
      typeof conceptDocument !== 'string' ||
      typeof conceptID   !== 'string') {
    throw new TypeError(
      'getModelData(): conceptName, conceptType, conceptDocument, conceptID must be strings'
    );
  }
  if (
    !Array.isArray(conceptProperties) ||
    !Array.isArray(relationshipTypes)
  ) {
    throw new TypeError(
      'getModelData(): conceptProperties and relationshipTypes must be arrays'
    );
  }

  log.info(`getModelData(): extracting ${conceptProperties.length} props and ${relationshipTypes.length} rel types`);
  log.debug('modelMap:', JSON.stringify(modelMap));

  // Grab all elements
  const elems = toJsArray($('element').toArray());
  log.info(`Found ${elems.length} elements in model`);

  // Pre-fetch all relationships
  const rels = toJsArray($('relationship').toArray());

  // Build raw data objects
  const data = elems.map(el => {
    const obj = {};
    // 1) Basic fields
    obj[conceptName] = el.name || '';
    // obj[conceptType] = (el.type && el.type.name) || '';
    obj[conceptType] = el.type  || '';
    obj[conceptDocument] = el.documentation || '';
    obj[conceptID]   = el.id || '';

    // 2) Element properties
    conceptProperties.forEach(propKey => {
      obj[propKey] = (el.prop(propKey) || '').toString();
    });

    // 3) Outgoing relationships by type
    relationshipTypes.forEach(relType => {
      const targets = rels
        .filter(r =>
          r.type && r.type.name === relType &&
          r.source && r.source.id === el.id
        )
        .map(r => (r.target && r.target.id) || '');
      obj[relType] = targets.join(',');
    });

    // 4) Any other custom functions
    if (dataUtils.isObject(others)) {
      Object.entries(others).forEach(([key, fn]) => {
        if (typeof fn === 'function') {
          try {
            obj[key] = fn(el);
          }
          catch (err) {
            log.error(`getModelData: error in others["${key}"] for element ${el.id}: ${err}`);
            obj[key] = '';
          }
        }
      });
    }

    return obj;
  });

  // Preview first five
  log.debug(
    'getModelData() preview:\n' +
    data.slice(0,5)
      .map((rec, i) => `#${i+1} ${JSON.stringify(rec, null, 2)}`)
      .join('\n\n')
  );

  return data;
}

/**
 * Maps an array of raw modelData objects into record objects keyed by propKeys.
 *
 * @param {Object[]} modelData  Output from getModelData()
 * @param {string[]} propKeys   Desired output keys
 * @returns {Object[]}          Array of records with only propKeys present
 * @throws {TypeError} on invalid inputs
 */
function mapModelDataToRecords(modelData, propKeys) {
  if (!Array.isArray(modelData)) {
    throw new TypeError('mapModelDataToRecords(): modelData must be an array');
  }
  if (!Array.isArray(propKeys)) {
    throw new TypeError('mapModelDataToRecords(): propKeys must be an array');
  }

  log.info(`mapModelDataToRecords(): mapping to ${propKeys.length} keys`);
  log.debug('propKeys:', JSON.stringify(propKeys));

  const records = modelData.map((item, idx) => {
    if (!dataUtils.isObject(item)) {
      log.error(`mapModelDataToRecords: skipping non-object at index ${idx}`);
      return null;
    }
    const rec = {};
    propKeys.forEach(key => {
      const v = item[key];
      rec[key] = v != null ? v.toString() : '';
    });
    return rec;
  }).filter(r => r !== null);

  // Preview first five
  log.debug(
    'mapModelDataToRecords() preview:\n' +
    records.slice(0,5)
      .map((r,i) => `#${i+1} ${JSON.stringify(r, null, 2)}`)
      .join('\n\n')
  );

  return records;
}

/**
 * Extracts **all** Archi elements into ModelEntry[].
 *
 * @param {string[]} propKeys
 *   List of all property keys (columns) expected downstream.
 * @returns {{ el: IElement, row: Object, sheetRow: number }[]}
 */
function getModelBlankEntries(propKeys) {
  if (!Array.isArray(propKeys)) {
    throw new TypeError('getModelEntries(): propKeys must be an array of strings');
  }
  log.info(`getModelEntries(): extracting ${propKeys.length} columns for every model element`);

  const allElems = toJsArray($('element').toArray());
  log.info(`Total elements in model: ${allElems.length}`);

  // build {el, row, sheetRow} for each element
  const entries = allElems.map((el, i) => {
    const row = {};
    propKeys.forEach(key => { row[key] = ''; });
    return { el, row, sheetRow: i + 1 };
  });

  log.debug(
    'getModelEntries() preview:\n' +
    entries.slice(0,5)
      .map(({ sheetRow, row }, ix) =>
        `#${ix+1} (sheetRow=${sheetRow}): ${JSON.stringify(row)}`
      ).join('\n')
  );

  return entries;
}

/**
 * Ensure there’s an active Archi model.  If none is in context, prompt the user to
 * either create a new model (via CLI) or select an existing .archimate file.
 * @returns {object} The current model instance
 * @throws {Error} If the user cancels or after prompting
 */
function promptForModel() {
    // Ask user what to do when no model is loaded
    var createNew = window.confirm(
        "No active model detected.\n\n" +
        "OK → Create a new model (CLI: add --createEmptyModel)\n" +
        "Cancel → Open an existing model file"
    );
    if (createNew) {
        window.alert(
            "Please re-run this script with the Archi CLI option:\n" +
            "--createEmptyModel\n\n" +
            "and then --script.runScript <this script>"
        );
    } else {
        // Let them pick a .archimate file
        var filePath = window.promptOpenFile(
            "Select an existing Archi model to load",
            "archimate"
        );
        if (filePath) {
            window.alert(
                "Please re-run this script with:\n" +
                "--loadModel \"" + filePath + "\"\n" +
                "--script.runScript <this script>"
            );
        }
    }
    throw new Error("Model selection required");
}

function ensureModelLoaded() {
    if (typeof model === 'undefined' || model === null) {
        promptForModel();
    }
    return model;
}

/**
 * Create or retrieve an ArchiMate concept in the current model.
 *
 * @param {Object} opts
 * @param {string} opts.name           – Concept name
 * @param {string} opts.type           – ArchiMate type string (e.g. "business-actor")
 * @param {string} opts.documentation  – Documentation text for the concept
 * @param {string} [opts.action="skip"]–
 *        "skip"     → if exact match exists, return it;
 *        "duplicate"→ always create a new one;
 *        "update"   → if same name+type exists, update its documentation.
 * @returns {string} The concept’s ID (new or existing)
 */
function createOrRetrieveConcept({ name, type, documentation, action }) {
    action = action || "skip";
    var mdl = ensureModelLoaded();

    // Determine matching elements
    var candidates;
    if (action === "update") {
        // match by name+type only
        candidates = $(type).filter(function(e) {
            return e.name === name;
        });
    } else {
        // match by name+type+documentation
        candidates = $(type).filter(function(e) {
            return e.name === name && e.documentation === documentation;
        });
    }

    if (candidates.size() > 0) {
        var existing = candidates.first();
        if (action === "skip") {
            return existing.id;
        }
        if (action === "update") {
            existing.documentation = documentation;
            return existing.id;
        }
        // "duplicate" → fall through to creation
    }

    // Create a brand-new concept
    var newElem = mdl.createElement(type, name);
    newElem.documentation = documentation;
    return newElem.id;
}

/**
 * Apply a list of custom properties from your data records onto model concepts.
 *
 * @param {Object|Array<Object>} records
 *        Either an object of records (values are row‐objects) or an array of row‐objects,
 *        each must include a `model_id` field referring to an Archi element ID.
 * @param {Array<string>} propertiesList
 *        The list of column names (properties) to push into each element.
 */
function applyPropertiesToModel(records, propertiesList) {
  const recs = Array.isArray(records) ? records : Object.values(records);
  const seen = {};

  recs.forEach(rec => {
    const id = rec.model_id;
    if (!id || seen[id]) return;
    seen[id] = true;

    const elem = $(`#${id}`).first();
    if (!elem) {
      log.warn(`No element found with ID ${id}; skipping property update.`);
      return;
    }

    propertiesList.forEach(propName => {
      if (!(propName in rec)) return;
      const newVal   = rec[propName];
      const existing = elem.prop(propName);

      if (existing === newVal) {
        log.debug(`Element ${id}: property "${propName}" already="${newVal}", skipping.`);
      }
      else {
        // create/update: true allows creation if missing
        elem.prop(propName, newVal, true);
        log.info(`Element ${id}: set property "${propName}" = "${newVal}".`);
      }
    });
  });
}

/**
 * Apply (or overwrite) a “specialization” value from your data records onto model concepts.
 *
 * @param {Object|Array<Object>} records
 *        Either an object of records or an array of row‐objects, each including `model_id`.
 * @param {string} specializationField
 *        The column name whose value should become the element’s specialization.
 */
function applySpecializationToModel(records, specializationField) {
  const recs = Array.isArray(records) ? records : Object.values(records);
  const seen = {};

  recs.forEach(rec => {
    const id = rec.model_id;
    if (!id || seen[id]) return;
    seen[id] = true;

    const elem = $(`#${id}`).first();
    if (!elem) {
      log.warn(`No element found with ID ${id}; skipping specialization.`);
      return;
    }

    if (specializationField in rec) {
      const spec = rec[specializationField];
      elem.specialization = spec;
      log.info(`Element ${id}: specialization set to "${spec}".`);
    }
  });
}

/**
 * Create one ArchiMate view per distinct domain value and add only
 * the elements not already present (by ID) into it.
 *
 * @param {Object|Array<Object>} records
 *   Your imported data, either as an object or an array of row‐objects.
 *   Each record **must** include:
 *     - model_id       (the Archi element ID)
 *     - the field named by viewsColumn
 * @param {string} viewsColumn
 *   The record property whose distinct values become view names.
 */
function createViewsFromData(records, viewsColumn) {
  const recs = Array.isArray(records) ? records : Object.values(records);

  // Group records by domain
  const domainMap = recs.reduce((map, rec) => {
    const domain = rec[viewsColumn];
    if (domain) {
      (map[domain] = map[domain] || []).push(rec);
    }
    return map;
  }, {});

  const model = ensureModelLoaded();

  Object.entries(domainMap).forEach(([domain, group]) => {
    // Find or create the view
    let view = $("archimate-diagram-model")
                .filter(v => v.name === domain)
                .first();
    if (!view) {
      view = model.createArchimateView(domain);
      log.info(`Created view "${domain}"`);
    }
    else {
      log.info(`Using existing view "${domain}"`);
    }

    // Grab existing diagram objects once for efficiency
    const existingObjs = $(view).children();

    // For each record, add its element if not already in the view
    group.forEach(rec => {
      const id = rec.model_id;
      if (!id) {
        log.warn(`Record missing model_id; skipping for domain "${domain}".`);
        return;
      }

      const elem = $(`#${ id }`).first();
      if (!elem) {
        log.warn(`No element with ID=${id}; skipping for view "${domain}".`);
        return;
      }

      // Check if any existing diagram-object references this element ID
      const alreadyHere = existingObjs
        .filter(obj => obj.element && obj.element.id === id);

      if (alreadyHere.size() > 0) {
        log.debug(`Element ID=${id} already in view "${domain}", skipping.`);
      }
      else {
        view.add(elem, 0, 0, -1, -1);
        log.info(`Added element ID=${id} to view "${domain}".`);
      }
    });
  });
}

// Finally, export the new functions alongside the originals
module.exports = Object.assign(module.exports || {}, {
  getModelData,
  mapModelDataToRecords,
  getModelBlankEntries,
  promptForModel,
  ensureModelLoaded,
  createOrRetrieveConcept,
  applyPropertiesToModel,
  applySpecializationToModel,
  createViewsFromData
});
  
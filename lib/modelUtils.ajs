/**
 * ./lib/modelUtils.ajs
 *
 * Utility for extracting **all** Archi model elements into
 * plain JS entries for downstream processing.
 */

// #region Load Dependencies

  const libPath = __DIR__ ;  
  const envPath = __DIR__+"../.env";
  console.log("envPath: " + envPath); 
  const loadEnv = require(libPath + 'loadEnv.ajs').loadEnv(envPath);
  const { log } = require(libPath + 'logger.ajs'); 
  const dataUtils = require(libPath + 'dataUtils.ajs');
  const common = require(libPath + 'commonUtils.ajs');
  const { toJsArray } = common

// #endregion Load Dependencies

/**
 * @typedef ModelEntry
 * @property {IElement} el        The raw Archi element
 * @property {Object}  row        Blank record initialized with propKeys
 * @property {number}  sheetRow   1-based index in this extracted list
 */

/**
 * @typedef ModelMap
 * @property {string}           conceptName          Output key for element.name
 * @property {string}           conceptType          Output key for element.type.name
 * @property {string}           conceptID            Output key for element.id
 * @property {string[]}         conceptProperties    Names of element properties to extract via el.prop()
 * @property {string[]}         relationshipTypes    Relationship-type names to gather outgoing targets
 * @property {Object<string,Function>} [others]
 *      Optional extra fields: key→fn(el) to compute additional values
 */

// #region Model
/**
 * Ensure there’s an active Archi model.  If none is in context, prompt the user to
 * either create a new model (via CLI) or select an existing .archimate file.
 * @returns {object} The current model instance
 * @throws {Error} If the user cancels or after prompting
 */
function promptForModel() {
    // Ask user what to do when no model is loaded
    var createNew = window.confirm(
        "No active model detected.\n\n" +
        "OK → Create a new model (CLI: add --createEmptyModel)\n" +
        "Cancel → Open an existing model file"
    );
    if (createNew) {
        window.alert(
            "Please re-run this script with the Archi CLI option:\n" +
            "--createEmptyModel\n\n" +
            "and then --script.runScript <this script>"
        );
    } else {
        // Let them pick a .archimate file
        var filePath = window.promptOpenFile(
            "Select an existing Archi model to load",
            "archimate"
        );
        if (filePath) {
            window.alert(
                "Please re-run this script with:\n" +
                "--loadModel \"" + filePath + "\"\n" +
                "--script.runScript <this script>"
            );
        }
    }
    throw new Error("Model selection required");
}

function ensureModelLoaded() {
    if (typeof model === 'undefined' || model === null) {
        promptForModel();
    }
    return model;
}
// #endregion Model

// #region Model Data
/**
 * Extracts raw data from every Archi element according to `modelMap`.
 *
 * @param {ModelMap} modelMap
 * @returns {Object[]} Array of objects, each with keys from `modelMap` (and `others`)
 * @throws {TypeError} on invalid inputs
 */
function getModelData(modelMap) {
  if (!dataUtils.isObject(modelMap)) {
    throw new TypeError('getModelData(): modelMap must be an object');
  }
  const {
    conceptName,
    conceptType,
    conceptID,
    conceptDocument,
    conceptProperties,
    relationshipTypes,
    others
  } = modelMap;
  // Validate required map fields
  if (typeof conceptName !== 'string' ||
      typeof conceptType !== 'string' ||
      typeof conceptDocument !== 'string' ||
      typeof conceptID   !== 'string') {
    throw new TypeError(
      'getModelData(): conceptName, conceptType, conceptDocument, conceptID must be strings'
    );
  }
  if (
    !Array.isArray(conceptProperties) ||
    !Array.isArray(relationshipTypes)
  ) {
    throw new TypeError(
      'getModelData(): conceptProperties and relationshipTypes must be arrays'
    );
  }

  log.info(`getModelData(): extracting ${conceptProperties.length} props and ${relationshipTypes.length} rel types`);
  log.debug('modelMap:', JSON.stringify(modelMap));

  // Grab all elements
  const elems = toJsArray($('element').toArray());
  log.info(`Found ${elems.length} elements in model`);

  // Pre-fetch all relationships
  const rels = toJsArray($('relationship').toArray());

  // Build raw data objects
  const data = elems.map(el => {
    const obj = {};
    // 1) Basic fields
    obj[conceptName] = el.name || '';
    // obj[conceptType] = (el.type && el.type.name) || '';
    obj[conceptType] = el.type  || '';
    obj[conceptDocument] = el.documentation || '';
    obj[conceptID]   = el.id || '';

    // 2) Element properties
    conceptProperties.forEach(propKey => {
      obj[propKey] = (el.prop(propKey) || '').toString();
    });

    // 3) Outgoing relationships by type
    relationshipTypes.forEach(relType => {
      const targets = rels
        .filter(r =>
          r.type && r.type.name === relType &&
          r.source && r.source.id === el.id
        )
        .map(r => (r.target && r.target.id) || '');
      obj[relType] = targets.join(',');
    });

    // 4) Any other custom functions
    if (dataUtils.isObject(others)) {
      Object.entries(others).forEach(([key, fn]) => {
        if (typeof fn === 'function') {
          try {
            obj[key] = fn(el);
          }
          catch (err) {
            log.error(`getModelData: error in others["${key}"] for element ${el.id}: ${err}`);
            obj[key] = '';
          }
        }
      });
    }

    return obj;
  });

  // Preview first five
  log.debug(
    'getModelData() preview:\n' +
    data.slice(0,5)
      .map((rec, i) => `#${i+1} ${JSON.stringify(rec, null, 2)}`)
      .join('\n\n')
  );

  return data;
}

/**
 * Maps an array of raw modelData objects into record objects keyed by propKeys.
 *
 * @param {Object[]} modelData  Output from getModelData()
 * @param {string[]} propKeys   Desired output keys
 * @returns {Object[]}          Array of records with only propKeys present
 * @throws {TypeError} on invalid inputs
 */
function mapModelDataToRecords(modelData, propKeys) {
  if (!Array.isArray(modelData)) {
    throw new TypeError('mapModelDataToRecords(): modelData must be an array');
  }
  if (!Array.isArray(propKeys)) {
    throw new TypeError('mapModelDataToRecords(): propKeys must be an array');
  }

  log.info(`mapModelDataToRecords(): mapping to ${propKeys.length} keys`);
  log.debug('propKeys:', JSON.stringify(propKeys));

  const records = modelData.map((item, idx) => {
    if (!dataUtils.isObject(item)) {
      log.error(`mapModelDataToRecords: skipping non-object at index ${idx}`);
      return null;
    }
    const rec = {};
    propKeys.forEach(key => {
      const v = item[key];
      rec[key] = v != null ? v.toString() : '';
    });
    return rec;
  }).filter(r => r !== null);

  // Preview first five
  log.debug(
    'mapModelDataToRecords() preview:\n' +
    records.slice(0,5)
      .map((r,i) => `#${i+1} ${JSON.stringify(r, null, 2)}`)
      .join('\n\n')
  );

  return records;
}

/**
 * Extracts **all** Archi elements into ModelEntry[].
 *
 * @param {string[]} propKeys
 *   List of all property keys (columns) expected downstream.
 * @returns {{ el: IElement, row: Object, sheetRow: number }[]}
 */
function getModelBlankEntries(propKeys) {
  if (!Array.isArray(propKeys)) {
    throw new TypeError('getModelEntries(): propKeys must be an array of strings');
  }
  log.info(`getModelEntries(): extracting ${propKeys.length} columns for every model element`);

  const allElems = toJsArray($('element').toArray());
  log.info(`Total elements in model: ${allElems.length}`);

  // build {el, row, sheetRow} for each element
  const entries = allElems.map((el, i) => {
    const row = {};
    propKeys.forEach(key => { row[key] = ''; });
    return { el, row, sheetRow: i + 1 };
  });

  log.debug(
    'getModelEntries() preview:\n' +
    entries.slice(0,5)
      .map(({ sheetRow, row }, ix) =>
        `#${ix+1} (sheetRow=${sheetRow}): ${JSON.stringify(row)}`
      ).join('\n')
  );

  return entries;
}
// #endregion Model Data

// #region  Concept
/**
 * Create or retrieve an ArchiMate concept in the current model.
 *
 * @param {Object} opts
 * @param {string} opts.name           – Concept name
 * @param {string} opts.type           – ArchiMate type string (e.g. "business-actor")
 * @param {string} opts.documentation  – Documentation text for the concept
 * @param {string} [opts.action="skip"]–
 *        "skip"     → if exact match exists, return it;
 *        "duplicate"→ always create a new one;
 *        "update"   → if same name+type exists, update its documentation.
 * @returns {string} The concept’s ID (new or existing)
 */
function createOrRetrieveConcept({ name, type, documentation, action }) {
    action = action || "skip";
    var mdl = ensureModelLoaded();

    // Determine matching elements
    var candidates;
    if (action === "update") {
        // match by name+type only
        candidates = $(type).filter(function(e) {
            return e.name === name;
        });
    } else {
        // match by name+type+documentation
        candidates = $(type).filter(function(e) {
            return e.name === name && e.documentation === documentation;
        });
    }

    if (candidates.size() > 0) {
        var existing = candidates.first();
        if (action === "skip") {
            return existing.id;
        }
        if (action === "update") {
            existing.documentation = documentation;
            return existing.id;
        }
        // "duplicate" → fall through to creation
    }

    // Create a brand-new concept
    var newElem = mdl.createElement(type, name);
    newElem.documentation = documentation;
    return newElem.id;
}
// #endregion  Concept

// #region Properties
/**
 * 1. Validate that a record can have properties applied:
 *    - has a model_id
 *    - the model element exists
 *
 * @param {Object} rec           – A data record with a `model_id` field
 * @returns {ArchimateConceptProxy|null}
 *    The element proxy if valid, or null if validation failed.
 */
function validatePropertyRecord(rec) {
  const id = rec.model_id;
  if (!id) {
    log.warn(`validatePropertyRecord: missing model_id, skipping record.`);
    return null;
  }
  const elem = $(`#${id}`).first();
  if (!elem) {
    log.warn(`validatePropertyRecord: no element found with ID=${id}, skipping.`);
    return null;
  }
  log.debug(`validatePropertyRecord: element ID=${id} found.`);
  return elem;
}

/**
 * 2. Check if a given property on an element already equals the desired value.
 *
 * @param {ArchimateConceptProxy} elem
 * @param {string} propName
 * @param {any} newVal
 * @returns {boolean}
 *    True if the element’s existing property equals newVal, false otherwise.
 */
function propertyExists(elem, propName, newVal) {
  const existing = elem.prop(propName);
  const matches = existing === newVal;
  log.debug(
    `propertyExists: element ID=${elem.id} property="${propName}" ` +
    `existing="${existing}", new="${newVal}", matches=${matches}`
  );
  return matches;
}

/**
 * 3. Create or update a property on an element, avoiding overload ambiguities.
 *
 * @param {ArchimateConceptProxy} elem
 * @param {string} propName
 * @param {any} newVal
 */
function setProperty(elem, propName, newVal) {
  // Determine argument type for .prop()
  const isBool = (typeof newVal === 'boolean');
  const valArg = isBool ? newVal : String(newVal);

  log.debug(
    `setProperty: element ID=${elem.id} ` +
    `prop="${propName}", typeof newVal=${typeof newVal}, ` +
    `calling prop("${propName}", ${JSON.stringify(valArg)})`
  );

  try {
    // Boolean overload when boolean, otherwise string overload
    elem.prop(propName, valArg);
    log.info(
      `setProperty: element ID=${elem.id} ` +
      `property "${propName}" set to "${valArg}".`
    );
  }
  catch (ex) {
    log.error(
      `setProperty: failed to set property "${propName}" ` +
      `on element ID=${elem.id}: ${ex.message || ex}`
    );
    throw ex;
  }
}

/**
 * Apply a list of custom properties from your data records onto model concepts,
 * using a Validate → Check → Create pattern.
 *
 * @param {Object|Array<Object>} records
 * @param {Array<string>} propertiesList
 */
function applyPropertiesToModel(records, propertiesList) {
  const recs = Array.isArray(records) ? records : Object.values(records);
  log.info(`applyPropertiesToModel: processing ${recs.length} record(s)`);

  recs.forEach((rec, idx) => {
    log.debug(`applyPropertiesToModel: record #${idx+1}`);
    const elem = validatePropertyRecord(rec);
    if (!elem) return;

    propertiesList.forEach(propName => {
      if (!rec.hasOwnProperty(propName)) {
        log.debug(`applyPropertiesToModel: record missing "${propName}", skipping.`);
        return;
      }
      const newVal = rec[propName];
      if (propertyExists(elem, propName, newVal)) {
        log.debug(`applyPropertiesToModel: property "${propName}" unchanged, skipping.`);
      }
      else {
        setProperty(elem, propName, newVal);
      }
    });
  });

  log.info(`applyPropertiesToModel: completed`);
}
// #endregion Property

// #region View
/**
 * Ensure a view with the given name exists.
 * @param {string} viewName
 * @returns {ArchimateDiagramModelProxy}
 */
function ensureViewExists(viewName) {
  const mdl = ensureModelLoaded();
  log.debug(`ensureViewExists: looking for view "${viewName}"`);
  const matches = $("archimate-diagram-model")
                    .filter(v => v.name === viewName);
  if (matches.size() > 0) {
    const v = matches.first();
    log.info(`ensureViewExists: using existing view "${viewName}" (ID=${v.id})`);
    return v;
  }
  log.info(`ensureViewExists: no view named "${viewName}", creating one`);
  const v = mdl.createArchimateView(viewName);
  log.info(`ensureViewExists: created view "${viewName}" (ID=${v.id})`);
  return v;
}

/**
 * Check if a diagram–object for this element already exists in the view.
 *
 * @param {ArchimateDiagramModelProxy} view
 * @param {ArchimateConceptProxy} element
 * @returns {boolean}
 */
function isDiagramObjectPresent(view, element) {
  const viewName = view.name;
  log.debug(`isDiagramObjectPresent: checking element ID=${element.id} on view "${viewName}"`);

  // Get all diagram‐objects (children of the view)
  const children = $(view).children();
  log.debug(`isDiagramObjectPresent: view "${viewName}" has ${children.size()} children`);

  // Convert the target element ID to a primitive string once
  const targetId = String(element.id).trim();
  log.debug(`isDiagramObjectPresent: normalized targetId="${targetId}"`);

  // Find any child whose .element.id matches targetId
  const matches = children.filter(obj => {
    // Skip any child without a concept link
    if (!obj.element) return false;

    // Normalize the child’s element.id
    const childId = String(obj.element.id).trim();
    const same    = (childId === targetId);
    log.debug(
      `  child.id=${obj.id}, childElement.id="${childId}", ` +
      `=== targetId? ${same}`
    );
    return same;
  });

  const present = matches.size() > 0;
  log.debug(`isDiagramObjectPresent: element ID=${targetId} present=${present}`);
  return present;
}

/**
 * Create a diagram‐object in the view for the given element if missing.
 * @param {ArchimateDiagramModelProxy} view
 * @param {ArchimateConceptProxy} element
 * @param {object} [coords]  – { x, y, w, h }
 */
function ensureDiagramObjectInView(view, element, coords = { x:0, y:0, w:-1, h:-1 }) {
  log.debug(
    `ensureDiagramObjectInView: checking element ID=${element.id} in view "${view.name}"`
  );
  if (isDiagramObjectPresent(view, element)) {
    log.debug(`ensureDiagramObjectInView: already exists, skipping element ID=${element.id}`);
    return;
  }
  log.info(
    `ensureDiagramObjectInView: adding element ID=${element.id} to view "${view.name}"`
  );
  try {
    view.add(element, coords.x, coords.y, coords.w, coords.h);
    log.info(
      `ensureDiagramObjectInView: added element ID=${element.id} ` +
      `at (${coords.x},${coords.y},${coords.w},${coords.h})`
    );
  }
  catch (ex) {
    log.error(
      `ensureDiagramObjectInView: failed to add element ID=${element.id} ` +
      `to view "${view.name}": ${ex.message||ex}`
    );
    throw ex;
  }
}

/**
 * Create one ArchiMate view per distinct domain value and add exactly
 * one diagram‐object per element (no duplicates).
 *
 * @param {Object|Array<Object>} dataObj
 * @param {string} viewsColumn
 */
function createViewsFromData(dataObj, viewsColumn) {
  log.info(`createViewsFromData: starting (viewsColumn="${viewsColumn}")`);

  // 1) Normalize records
  const records = Array.isArray(dataObj) ? dataObj : Object.values(dataObj);
  log.debug(`createViewsFromData: ${records.length} total record(s)`);

  // 2) Build domain → Set(model_ids)
  const domainMap = {};
  records.forEach((rec, idx) => {
    const domain = rec[viewsColumn];
    const id     = rec.model_id;
    if (!domain) {
      log.debug(`Record #${idx+1}: missing domain, skipping`);
      return;
    }
    if (!id) {
      log.warn(`Record #${idx+1}: domain="${domain}" missing model_id, skipping`);
      return;
    }
    if (!domainMap[domain]) {
      domainMap[domain] = new Set();
      log.debug(`createViewsFromData: new domain "${domain}"`);
    }
    domainMap[domain].add(id);
  });

  // 3) Iterate each domain
  Object.entries(domainMap).forEach(([domain, idSet]) => {
    log.info(`createViewsFromData: processing domain "${domain}" with ${idSet.size} element(s)`);

    // 3a) Ensure view exists
    const view = ensureViewExists(domain);

    // 3b) Add each element exactly once
    let added=0, skipped=0;
    idSet.forEach(id => {
      const elem = $(`#${id}`).first();
      if (!elem) {
        log.warn(`createViewsFromData: element ID=${id} not found, skipping`);
        skipped++;
        return;
      }
      if (isDiagramObjectPresent(view, elem)) {
        skipped++;
      } else {
        ensureDiagramObjectInView(view, elem);
        added++;
      }
    });

    log.info(
      `createViewsFromData: domain "${domain}" complete: ` +
      `added=${added}, skipped=${skipped}`
    );
  });

  log.info('createViewsFromData: all domains processed');
}

// #endregion Views

// #region Specialization
/**
 * For each record in records, apply the specialization named in `fieldName`.
 * If the element isn’t found, or the field is empty, logs and skips.
 *
 * @param {Object[]|Object} records
 *    Array (or object-of-rows) with each record containing:
 *      - model_id            (the element’s UUID)
 *      - [fieldName]         (the specialization to assign)
 * @param {string} fieldName
 *    The property name in each record holding the specialization.
 */
function applySpecializationToModel(records, fieldName) {
  const recs = Array.isArray(records) ? records : Object.values(records);
  const model = ensureModelLoaded();  // your existing helper to get/ask-for the model

  recs.forEach(rec => {
    const id = rec.model_id;
    const specName = rec[fieldName];
    if (!id || !specName) {
      log.warn(`Record missing model_id or "${fieldName}":`, rec);
      return;
    }

    const elem = $(`#${ id }`).first();
    if (!elem) {
      log.error(`No element found with ID=${id}; cannot apply specialization.`);
      return;
    }

    // 1) Guarantee specialization exists in the model
    ensureSpecializationExistsForType(model, elem.type, specName);

    // 2) Assign it to the element
    try {
      elem.specialization = specName;
      log.info(`Assigned specialization "${specName}" to element ID=${id}.`);
    }
    catch (e) {
      log.error(`Failed to assign specialization "${specName}" to element ID=${id}: ${e.message}`);
      throw e;
    }
  });
}
/**
 * Ensure a specialization profile exists for a given ArchiMate type.
 * Uses model.findSpecialization() to detect existing entries.
 * If missing, creates it; if present, skips creation.
 *
 * @param {string} conceptType  – ArchiMate type ID (e.g. "resource")
 * @param {string} name         – Specialization name (e.g. "Operations")
 * @returns {IProfile|null}     – The existing or newly created profile, or null if skipped
 */
function ensureSpecializationExistsForType(conceptType, name) {
  const mdl = ensureModelLoaded();

  // 1) Check for an existing specialization by name and type
  let spec = mdl.findSpecialization(name, conceptType);
  if (spec) {
    log.info(
      'Specialization "' + name +
      '" already exists for type "' + conceptType +
      '", skipping creation.'
    );
    return spec;
  }

  // 2) Not found → attempt to create it
  log.info(
    'Creating specialization "' + name +
    '" for type "' + conceptType + '"...'
  );
  try {
    spec = mdl.createSpecialization(name, conceptType);
    log.info(
      'Created specialization "' + name +
      '" for type "' + conceptType + '".'
    );
    return spec;
  }
  catch (ex) {
    const msg = ex.message || '';
    // 3) If creation fails due to it already existing, log and continue
    if (/already exists/i.test(msg) || /already defined/i.test(msg)) {
      log.warn(
        'Specialization "' + name +
        '" already defined for type "' + conceptType +
        '" (caught during create), skipping.'
      );
      return null;
    }
    // 4) Otherwise, rethrow
    log.error(
      'Could not create specialization "' + name +
      '" for "' + conceptType + '": ' + msg
    );
    throw ex;
  }
}

/**
 * Apply a specialization to a single element proxy.
 *
 * @param {Proxy} element – jArchi element proxy
 * @param {string} name  – Specialization name to assign
 */
function applySpecializationToElement(element, name) {
  if (!element || !name) {
    log.warn(`Skipping specialization; missing element or name.`);
    return;
  }
  // Ensure the profile exists first
  ensureSpecializationExistsForType(element.type, name);
  // Assign it
  element.specialization = name;
  log.info(`Assigned specialization "${name}" to element ID=${element.id}.`);
}

/**
 * Import/define all specializations found in your data
 * using the corrected helper above.
 *
 * @param {Object|Array<Object>} dataObj
 * @param {string} typeField – Record field for concept type
 * @param {string} specField – Record field for specialization name
 */
function importSpecializationsFromData(dataObj, typeField, specField) {
  log.info(`Importing specializations from "${specField}"…`);
  const rows = Array.isArray(dataObj) ? dataObj : Object.values(dataObj);
  const seen = new Set();

  rows.forEach((r, i) => {
    const type = r[typeField], spec = r[specField];
    if (!type || !spec) return;
    const key = `${type}::${spec}`;
    if (seen.has(key)) return;
    seen.add(key);
    log.info(`  Ensuring "${spec}" for type "${type}"…`);
    ensureSpecializationExistsForType(type, spec);
  });

  log.info(`importSpecializationsFromData processed ${seen.size} specializations.`);
}
// #endregion Specializations

// #region Relationships
/**
 * Create or skip an ArchiMate relationship of a given type between two elements.
 *
 * @param {String} sourceId     – The ID of the source element
 * @param {String} targetId     – The ID of the target element
 * @param {String} relType      – ArchiMate relationship type (e.g. "association-relationship")
 * @param {String} relName      – The name to assign to the new relationship
 * @returns {IArchimateRelationshipProxy|null}
 */
function ensureRelationship(sourceId, targetId, relType, relName) {
  const mdl = ensureModelLoaded();

  // 1) Lookup element proxies by ID
  const sourceElem = $(`#${ sourceId }`).first();
  const targetElem = $(`#${ targetId }`).first();

  if (!sourceElem) {
    log.warn(`Source element ${sourceElem} with ID=${sourceId} not found; skipping relationship "${relName}".`);
    return null;
  }
  if (!targetElem) {
    log.warn(`Target element ${targetElem} with ID=${targetId} not found; skipping relationship "${relName}".`);
    return null;
  }

  log.debug(`Checking for existing [${relType}] from (${sourceId}:${sourceElem})  → (${targetId}:${targetElem})`);

  // 2) Find existing same-type relationships between these IDs
  const allRels = $(relType);
  const exists = allRels.filter(r =>
    r.source && r.source.id === sourceId &&
    r.target && r.target.id === targetId
  );

  if (exists.size() > 0) {
    log.debug(
      `Relationship "${relType}" from (${sourceId}:${sourceElem})  → (${targetId}:${targetElem}) already exists (` +
      `name="${exists.first().name}"), skipping creation.`
    );
    return exists.first();
  }

  // 3) Create a new relationship
  log.info(
    `Creating relationship [${relType}] ` +
    `(${sourceId}:${sourceElem})  → (${targetId}:${targetElem}) named "${relName}".`
  );

  let rel;
  try {
    rel = mdl.createRelationship(relType, "", sourceElem, targetElem);
    rel.name = relName;
    log.info(`Created relationship ID=${rel.id} name="${relName}".`);
  }
  catch (ex) {
    log.error(
      `Failed to create relationship [${relType}] ` +
      `${sourceId}→${targetId}: ${ex.message || ex}`
    );
    throw ex;
  }

  return rel;
}

/**
 * From your data records, create grouping relationships.
 *
 * @param {Object|Array<Object>} dataObj
 *   Parsed data from Excel (object or array of row-records).
 * @param {Object} groupingConfig
 * @param {String} groupingConfig.Field
 *   Column header whose value is the grouping label (e.g. "Grouped_under").
 * @param {Object} groupingConfig.Relationship
 * @param {String} groupingConfig.Relationship.Type
 *   Column header for relationship type (e.g. "Grouping_relationshipType").
 * @param {String} groupingConfig.Relationship.default
 *   Default relationship type if the cell is empty.
 * @param {String} groupingConfig.Relationship.sourceElemtn
 *   Column header for source element ID.
 * @param {String} groupingConfig.Relationship.targetElement
 *   Column header for target element ID.
 */
function applyGroupingRelationships(dataObj, groupingConfig) {
  log.info('Applying grouping relationships…');
  // Normalize input to array
  const rows = Array.isArray(dataObj) ? dataObj : Object.values(dataObj);

  // Destructure config keys
  const {
    Field: groupKey,
    Relationship: {
      Type: typeKey,
      default: defaultType,
      sourceElemtn: sourceKey,
      targetElement: targetKey
    }
  } = groupingConfig;

  rows.forEach((rec, idx) => {
    const groupVal = rec[groupKey];
    const relType  = rec[typeKey] || defaultType;
    const srcId    = rec[sourceKey];
    const tgtId    = rec[targetKey];

    log.debug(`Row ${idx+1}: grouping="${groupVal}", type="${relType}", src="${srcId}", tgt="${tgtId}"`);

    if (!groupVal || !srcId || !tgtId) {
      log.warn(`Row ${idx+1}: missing one of [${groupKey},${sourceKey},${targetKey}], skipping.`);
      return;
    }

    // Lookup element proxies
    const srcElem = $(`#${ srcId }`).first();
    const tgtElem = $(`#${ tgtId }`).first();

    log.debug(`Row ${idx+1}: source/target elements (${srcId} -> ${srcElem}, ${tgtId} -> ${tgtElem})`);

    if (!srcElem || !tgtElem) {
      log.warn(`Row ${idx+1}: could not find source/target elements (${srcId} -> ${srcElem}, ${tgtId} -> ${tgtElem}), skipping.`);
      return;
    }

    // Name = <type>-<groupValue>
    const relName = `${ relType }-${ groupVal }`;

    // Create or skip
    try {
      ensureRelationship(srcId, tgtId, relType, relName);
    }
    catch (ex) {
      log.error(`Row ${idx+1}: failed to ensure relationship: ${ex}`);
      throw ex;
    }
  });

  log.info(`applyGroupingRelationships complete (${rows.length} rows processed)`);
}
// #endregion Relationships


function getActiveModel(){
    if(typeof model==="undefined"||!model)throw new Error("No active model found.");
    log.info("Using model: "+model.name);
    return model;
}

/**
 * Gets all root folders in the model as an array, and also builds a map by name.
 * Uses jArchi idiom for maximum compatibility. Logs each folder.
 *
 * @param {object} model - The ArchiMate model object
 * @returns {{ array: object[], map: object }}
 *   - array: JS array of root folder objects
 *   - map: JS object, name → folder
 */
function getRootFolders(model) {
    if (!model) {
        log.error("getRootFolders: model is undefined.");
        return { array: [], map: {} };
    }
    // Use jArchi idiom: get all direct child folders of the model
    const rootFoldersArr = $(model).children('folder').toArray();
    if (rootFoldersArr.length === 0) {
        log.warn("getRootFolders: No root folders found in the model.");
    } else {
        log.debug("Root folders (names): " + rootFoldersArr.map(f => f.name).join(", "));
    }
    // Build a map by name for quick lookup
    const rootFoldersByName = {};
    rootFoldersArr.forEach(function(folder) {
        rootFoldersByName[folder.name] = folder;
        log.debug(`[getRootFolders] Mapped root folder: '${folder.name}'`);
    });
    return { array: rootFoldersArr, map: rootFoldersByName };
}

/**
 * Gets all immediate subfolders of a folder as a JS array.
 * Logs found subfolders.
 *
 * @param {object} folder - Parent folder object
 * @returns {object[]} Array of subfolder objects
 */
function getSubfolders(folder) {
    if (!folder) {
        log.error("getSubfolders: parent folder is undefined.");
        return [];
    }
    const subfolders = $(folder).children('folder').toArray();
    log.debug(`[getSubfolders] Folder '${folder.name}' has subfolders: [${subfolders.map(f => f.name).join(", ")}]`);
    return subfolders;
}

/**
 * Find the first folder with the given name using JArchi selector syntax.
 * Logs the result to the console.
 * 
 * @param {string} folderName - The folder name to find.
 * @returns {Object|null} The folder object if found, otherwise null.
 */
function findFolderByName_selector(folderName) {
    var escapedName = escapeFolderName(folderName);
    var folderCollection = $("folder." + escapedName).first();

    if (folderCollection && folderCollection.size() > 0) {
        var folder = folderCollection.get(0);
        log.debug("Found folder (selector): " + folder.name + " (id: " + folder.id + ")");
        return folder;
    } else {
        log.debug("No folder found with name '" + folderName + "' (selector).");
        return null;
    }
}

/**
 * Find all folders with the given name using filter(function).
 * Logs results to the console.
 * 
 * @param {string} folderName - The exact folder name to match.
 * @returns {Collection} JArchi collection of folders matching the name (empty if none).
 */
function findFoldersByName_filter(folderName) {
    var folders = $("folder").filter(function(f) {
        return f.name === folderName;
    });

    if (folders && folders.size() > 0) {
        log.debug("Found " + folders.size() + " folder(s) (filter):");
        folders.each(function(folder) {
            log.debug("  - " + folder.name + " (id: " + folder.id + ")");
        });
    } else {
        log.debug("No folder found with name '" + folderName + "' (filter).");
    }

    return folders;
}

/**
 * Find the first subfolder with the given name under a specified parent folder.
 * Logs the result to the console.
 * 
 * @param {Object} parentFolderObj - JArchi folder object under which to search.
 * @param {string} subFolderName - The name of the subfolder to find.
 * @returns {Object|null} The subfolder object if found, else null.
 */
function findSubFolderByName(parentFolderObj, subFolderName) {
    if (!parentFolderObj) {
        log.debug("Parent folder object is null or undefined.");
        return null;
    }

    var escapedName = escapeFolderName(subFolderName);
    // Get immediate children folders matching the subFolderName selector
    // Use .children("folder.<name>") to find direct subfolders with the name
    var matchingSubFolders = parentFolderObj.children("folder." + escapedName).first();

    if (matchingSubFolders && matchingSubFolders.size() > 0) {
        var subFolder = matchingSubFolders.get(0);
        log.debug("Found subfolder: " + subFolder.name + " (id: " + subFolder.id + ") under parent folder: " + parentFolderObj.name);
        return subFolder;
    } else {
        log.debug("No subfolder named '" + subFolderName + "' found under parent folder: " + parentFolderObj.name);
        return null;
    }
}

/**
 * Find all subfolders with a given name under a specified parent folder name.
 * Logs results to the console.
 * 
 * @param {string} parentFolderName - Name of the parent folder to search within.
 * @param {string} subFolderName - Name of the subfolder(s) to find under the parent.
 * @returns {Collection} JArchi collection of matching subfolders (empty if none).
 */
function findSubfoldersUnderParent(parentFolderName, subFolderName) {
    // Find all parent folders matching parentFolderName
    var parents = $("folder").filter(function(f) {
        return f.name === parentFolderName;
    });

    if (!parents || parents.size() === 0) {
        log.debug("Parent folder '" + parentFolderName + "' not found.");
        return $();  // empty collection
    }

    var matchedSubfolders = $(); // empty collection to accumulate results

    parents.each(function(parent) {
        // Get immediate children of this parent folder that are folders
        var childrenFolders = parent.children("folder");

        // Filter children by subFolderName
        var filtered = childrenFolders.filter(function(f) {
            return f.name === subFolderName;
        });

        // Accumulate matching subfolders
        matchedSubfolders = matchedSubfolders.add(filtered);
    });

    if (matchedSubfolders.size() > 0) {
        log.debug("Found " + matchedSubfolders.size() + " subfolder(s) named '" + subFolderName +
                    "' under parent folder '" + parentFolderName + "':");
        matchedSubfolders.each(function(f) {
            log.debug("  - " + f.name + " (id: " + f.id + ")");
        });
    } else {
        log.debug("No subfolders named '" + subFolderName + "' found under parent folder '" +
                    parentFolderName + "'.");
    }

    return matchedSubfolders;
}

/**
 * Find all subfolders with a given name under a specified parent folder object.
 * Logs results to the console.
 * 
 * @param {Object} parentFolder - JArchi Folder object to search within.
 * @param {string} subFolderName - Name of the subfolder(s) to find under the parent.
 * @returns {Collection} JArchi collection of matching subfolders (empty if none).
 */
function getImmediateChildFolders(parentFolder) {
    if (!parentFolder || parentFolder.type !== "folder") {
        log.debug("Invalid parentFolder provided. It must be a JArchi Folder object.");
        return $();  // empty collection
    }

    var allFolders = $("folder");

    var children = allFolders.filter(function(f) {
        return f.parent != null && f.parent.id === parentFolder.id;
    });

    return children;
}
function findSubfoldersUnderParentObject(parentFolder, subFolderName) {
    if (!parentFolder || parentFolder.type !== "folder") {
        log.debug("Invalid parentFolder provided. It must be a JArchi Folder object.");
        return $();  // empty collection
    }
    
    if (typeof subFolderName !== "string" || subFolderName.trim() === "") {
        log.debug("Invalid subFolderName provided. It must be a non-empty string.");
        return $();  // empty collection
    }

    // Get immediate child folders of the parent folder
    var childrenFolders = getImmediateChildFolders(parentFolder);

    // Filter children by name
    var matchedSubfolders = childrenFolders.filter(function(f) {
        return f.name === subFolderName;
    });

    if (matchedSubfolders.size() > 0) {
        log.debug("Found " + matchedSubfolders.size() + " subfolder(s) named '" + subFolderName +
                    "' under parent folder '" + parentFolder.name + "':");
        matchedSubfolders.each(function(f) {
            log.debug("  - " + f.name + " (id: " + f.id + ")");
        });
    } else {
        log.debug("No subfolders named '" + subFolderName + "' found under parent folder '" +
                    parentFolder.name + "'.");
    }
    log.debug("Found " + matchedSubfolders + " of Type: " + matchedSubfolders.type +" subfolder(s) named '" + subFolderName +
                "' under parent folder '" + parentFolder.name + "':");
    return matchedSubfolders;
}

/**
 * Create a subfolder with the specified name under the given parent folder object.
 * Performs safety checks and logs actions and failures.
 * 
 * @param {Object} parentFolderObj - JArchi Folder object under which to create the subfolder.
 * @param {string} subFolderName - Name of the subfolder to create.
 * @returns {Object|null} The newly created subfolder object, or null if creation failed.
 */
function createSubfolderUnderParent(parentFolderObj, subFolderName) {
    if (!parentFolderObj) {
        log.debug("Error: parentFolderObj is null or undefined. Cannot create subfolder.");
        return null;
    }

    if (typeof subFolderName !== "string" || subFolderName.trim() === "") {
        log.debug("Error: subFolderName must be a non-empty string.");
        return null;
    }

    if (parentFolderObj.type !== "folder") {
        log.debug("Error: The parentFolderObj is not a folder (type = '" + parentFolderObj.type + "').");
        return null;
    }

    // Get all folders in the model
    var allFolders = $("folder");

    // Filter to find existing subfolders with the same name under parentFolderObj
    var existingSubfolders = allFolders.filter(function(f) {
        return f.parent != null && f.parent.id === parentFolderObj.id && f.name === subFolderName;
    });

    if (existingSubfolders && existingSubfolders.size() > 0) {
        log.debug("Subfolder '" + subFolderName + "' already exists under parent folder '" + parentFolderObj.name + "'.");
        return existingSubfolders.get(0);  // Return the existing subfolder object
    }

    try {
        // Create the subfolder under the parent folder
        var newSubfolder = parentFolderObj.createFolder(subFolderName);

        if (newSubfolder && newSubfolder.type === "folder") {
            log.debug("Successfully created subfolder '" + subFolderName + "' under parent folder '" + parentFolderObj.name + "'.");
            return newSubfolder;
        } else {
            log.debug("Failed to create subfolder '" + subFolderName + "'. The returned object is invalid.");
            return null;
        }
    } catch (e) {
        log.debug("Exception while creating subfolder: " + e.message);
        return null;
    }
}

function getOrCreateSubfolder(parentFolder,subfolderName){     
    
    var pf = findFoldersByName_filter(parentFolder).first();
    if(!pf)throw new Error("Could not find parent folder: "+parentFolder);
    else log.info("Found parent folder: "+parentFolder+ " Type: "+pf.type);
    
    log.debug("searching for sub folder: " + subfolderName);
    var subfolder=findSubfoldersUnderParentObject(pf,subfolderName);

    if(subfolder.size()==0){
        log.info("Creating subfolder '"+ subfolderName +"'");
        subfolder=createSubfolderUnderParent(pf, subfolderName);
        if(!subfolder)throw new Error("Could not create subfolder: "+subfolderName);
    }else{
        log.info("Found subfolder '"+ subfolder.first().name + "'");
    }
    return subfolder;
}

/**
 * Checks which ArchiMate view(s) contain the given element by scanning each view’s diagram objects.
 * Uses view.find() to retrieve all visual objects in each view and matches on .concept.id
 * @param {EObjectProxy} elem
 * @returns {string|string[]} view name, array of names, or "Orphan"
 *
 * Each visual object (.find()) has a .concept property linking back to the model element fileciteturn4file17.
 */
function getElementViews(elem) {
const viewNames = [];
// Iterate all views in the model
const allViews = toJsArray($('view').toArray());
allViews.forEach(view => {
    // Retrieve all visual objects in this view
    const allObjects = toJsArray($(view).find().toArray());
    // Check if any object represents our element
    for (let obj of allObjects) {
    if (obj.concept && obj.concept.id === elem.id) {
        viewNames.push(view.name);
        break;
    }
    }
});
log.debug('getElementViews(' + elem.id + '): ' + viewNames);
if (!viewNames.length) return 'Orphan';
return viewNames.length === 1 ? viewNames[0] : viewNames;
}

/**
 * Get values of custom properties for an element.
 * @param {Object} el
 * @param {Array<string>} keys
 * @returns {Array<any>}
 */
function collectPropValues(el, keys) {
const props = el.properties ? el.properties() : {};
return keys.map(k => props.hasOwnProperty(k) ? el.prop(k) : '');
}

/**
 * buildProperties
 * Generic property and metadata extractor for ArchiMate model elements.
 *
 * @param {EObjectProxy|null} el - The model element (null for orphan).
 * @param {Array<string>} modelProperties - List of ArchiMate property names to extract via .prop().
 * @param {Array<Object>} supplementProperties - List of {key, fn} computed property configs.
 * @param {Object} ctx - Context object providing helpers and extra data for property functions.
 * @param {Object} [logger] - Logger object with .info()/.log.warn() (defaults to console).
 * @returns {Object} rec - The assembled property record.
 */
function buildProperties(el, modelProperties, supplementProperties, ctx) {
    let rec = {};    

    if (el) {
        log.debug("Building properties for: " + (el.name || el.id));
        // Extract plain model properties
        modelProperties.forEach(function(propName) {
            let value = el.prop(propName);
            rec[propName] = (typeof value !== 'undefined' && value !== null) ? value : '';
        });
        // Extract computed supplement properties
        supplementProperties.forEach(function(field) {
            try {
                rec[field.key] = field.fn(el, ctx);
            } catch (err) {
                log.warn("Error building supplement property [" + field.key + "]: " + err);
                rec[field.key] = '';
            }
        });
    } else {
        log.warn("Element is null/undefined (Orphan record).");
        modelProperties.forEach(function(propName) {
            rec[propName] = '';
        });
        supplementProperties.forEach(function(field) {
            try {
                rec[field.key] = field.fn(null, ctx);
            } catch (err) {
                rec[field.key] = '';
            }
        });
    }
    return rec;
}

/**
 * Merges properties from source object into target object, but only for keys present in propKeys.
 * Existing values in target take priority unless overwrite=true.
 * 
 * @param {Object} target    - The main record object.
 * @param {Object} source    - The dynamic properties to merge in.
 * @param {Array}  propKeys  - List of allowed keys.
 * @param {boolean} [overwrite=false] - If true, always overwrite.
 * @returns {Object} The merged object.
 */
function mergeDynamicProps(target, source, propKeys, overwrite) {
    overwrite = overwrite || false;
    Object.keys(source).forEach(key => {
        if (propKeys.includes(key)) {
            if (overwrite || !(key in target) || target[key] === '') {
                target[key] = source[key];
            }
        }
    });
    return target;
}

/**
 * Builds a matrix of relationships for a given list of concepts.
 * Uses jArchi's inRels()/outRels() to fetch incoming or outgoing relationships.
 *
 * @param {ArchiConcept[]} concepts – Array of concept elements to process.
 * @param {'in'|'out'} direction – 'out' to list outgoing, 'in' to list incoming relationships.
 * @returns {string[][]} A 2D array: first row = headers, subsequent rows = relationship data.
 */
function conceptRelationshipMap(concepts, direction) {
  log.info('[ConceptRelationshipMap] Building concept-relationship map...');

  const headers = [
    'Source Name', 'Source Type', 'Source ID',
    'Relationship Type', 'Relationship ID',
    'Target Name', 'Target Type', 'Target ID'
  ];
  const rows = [ headers ];

  // Validate inputs
  if (!Array.isArray(concepts) || concepts.length === 0) {
    log.error('[ConceptRelationshipMap] Input concepts array is empty or invalid!');
    return rows;
  }
  if (direction !== 'in' && direction !== 'out') {
    log.error(`[ConceptRelationshipMap] Invalid direction: ${direction}. Must be "in" or "out".`);
    return rows;
  }
  log.info(`[ConceptRelationshipMap] Processing ${concepts.length} concepts, direction="${direction}".`);

  // Counters for diagnostics
  let validConceptCount      = 0;
  let conceptsWithRels       = 0;
  let totalRels              = 0;
  let relNoEndpointCount     = 0;
  let relValidCount          = 0;

  try {
    concepts.forEach((concept, idx) => {
      if (!concept) {
        log.error(`[ConceptRelationshipMap] Concept at index ${idx} is null/undefined, skipping.`);
        return;
      }
      validConceptCount++;

      // Fetch relationships via jArchi helper
      const rels = direction === 'out'
        ? $(concept).outRels().toArray()
        : $(concept).inRels().toArray();

      if (rels.length === 0) {
        log.debug(`[ConceptRelationshipMap] Concept "${concept.name}" (${concept.id}) has no ${direction} relationships.`);
        return;
      }

      conceptsWithRels++;
      totalRels += rels.length;

      rels.forEach((rel, relIdx) => {
        // Determine source/target based on direction
        const src = direction === 'out' ? concept : rel.source;
        const tgt = direction === 'out' ? rel.target : concept;

        if (!src || !tgt) {
          relNoEndpointCount++;
          log.error(
            `[ConceptRelationshipMap] Relationship ID "${rel.id}" missing ${
              !src ? 'source' : 'target'
            } (concept index ${idx}, rel index ${relIdx}).`
          );
          return;
        }

        relValidCount++;
        rows.push([
          src.name || '',
          src.type || '',
          src.id   || '',
          rel.type || '',
          rel.id   || '',
          tgt.name || '',
          tgt.type || '',
          tgt.id   || ''
        ]);
      });
    });
  }
  catch (err) {
    log.error(`[ConceptRelationshipMap] Unexpected error: ${err}`);
    return rows;
  }

  // Detailed debug summary
  
    log.debug(`[ConceptRelationshipMap] Valid concepts: ${validConceptCount} / ${concepts.length}`);
    log.debug(`[ConceptRelationshipMap] Concepts with relationships: ${conceptsWithRels}`);
    log.debug(`[ConceptRelationshipMap] Total relationships encountered: ${totalRels}`);
    log.debug(`[ConceptRelationshipMap] Relationships mapped with valid endpoints: ${relValidCount}`);
    log.debug(`[ConceptRelationshipMap] Relationships missing endpoint(s): ${relNoEndpointCount}`);
    log.debug(`[ConceptRelationshipMap] Final row count (excluding header): ${rows.length - 1}`);


  return rows;
}

/**
 * Given a file path, returns the parent folder path.
 * @param {string} filePath
 * @returns {string} Parent directory path
 */
function getParentFolderPath(filePath) {
    var File = Java.type('java.io.File');
    var file = new File(filePath);
    return file.getParent();
}

/**
 * Ensures a file path has the given extension (e.g., .xlsx)
 * @param {string} path 
 * @param {string} ext - e.g. ".xlsx"
 * @returns {string}
 */
function ensureFileExtension(path, ext) {
    if (!path.toLowerCase().endsWith(ext.toLowerCase())) {
        return path + ext;
    }
    return path;
}

/**
 * Check if a folder exists and is writable.
 * Logs diagnostics and returns true if folder exists and is writable, else false.
 * @param {string} folderPath - Absolute path to the folder (native format, e.g. C:\Users\me\Documents)
 * @returns {boolean}
 */
function checkFolderWritable(folderPath) {
    log.info('[checkFolderWritable] Checking folder: ' + folderPath);
    try {
        var File = Java.type('java.io.File');
        var folder = new File(folderPath);
        if (!folder.exists()) {
            log.error('[checkFolderWritable] Folder does not exist: ' + folderPath);
            return false;
        }
        if (!folder.isDirectory()) {
            log.error('[checkFolderWritable] Path is not a directory: ' + folderPath);
            return false;
        }
        if (!folder.canWrite()) {
            log.error('[checkFolderWritable] No write permission for: ' + folderPath);
            return false;
        }
        log.info('[checkFolderWritable] Folder exists and is writable.');
        return true;
    } catch (ex) {
        logJavaException('[checkFolderWritable] Exception:', ex);
        return false;
    }
}


// Finally, export the new functions alongside the originals
module.exports = Object.assign(module.exports || {}, {
  getModelData,
  mapModelDataToRecords,
  getModelBlankEntries,
  promptForModel,
  ensureModelLoaded,
  createOrRetrieveConcept,
  validatePropertyRecord,
  propertyExists,
  setProperty,
  applyPropertiesToModel,
  ensureSpecializationExistsForType,
  applySpecializationToModel,  // does not work
  applySpecializationToElement,
  importSpecializationsFromData,
  ensureRelationship,
  applyGroupingRelationships,
  ensureViewExists,
  isDiagramObjectPresent,
  ensureDiagramObjectInView,
  createViewsFromData,
  getActiveModel,
  getRootFolders,
  getSubfolders,
  findFolderByName_selector,
  findFoldersByName_filter,
  findSubFolderByName,
  findSubfoldersUnderParent,
  getImmediateChildFolders,
  findSubfoldersUnderParentObject,
  createSubfolderUnderParent,	    
  getOrCreateSubfolder,	
  getElementViews,
  collectPropValues,
  buildProperties,  	
  mergeDynamicProps,	
  conceptRelationshipMap,
  getParentFolderPath,
});
  
/**
 * ./lib/modelUtils.ajs
 *
 * Utility for extracting **all** Archi model elements into
 * plain JS entries for downstream processing.
 */

// Load shared libraries
  const libPath = __DIR__ ;  
  const envPath = __DIR__+"../.env";
  console.log("envPath: " + envPath); 
  const loadEnv = load(libPath + 'loadEnv.ajs').loadEnv(envPath);
  const { log } = require(libPath + 'logger.ajs'); 
  const dataUtils = require(libPath + 'data_utils.ajs');
  const common = require(libPath + 'common_utils.ajs');
  const { toJsArray } = common
  
  

/**
 * @typedef ModelEntry
 * @property {IElement} el        The raw Archi element
 * @property {Object}  row        Blank record initialized with propKeys
 * @property {number}  sheetRow   1-based index in this extracted list
 */

/**
 * @typedef ModelMap
 * @property {string}           conceptName          Output key for element.name
 * @property {string}           conceptType          Output key for element.type.name
 * @property {string}           conceptID            Output key for element.id
 * @property {string[]}         conceptProperties    Names of element properties to extract via el.prop()
 * @property {string[]}         relationshipTypes    Relationship-type names to gather outgoing targets
 * @property {Object<string,Function>} [others]
 *      Optional extra fields: keyâ†’fn(el) to compute additional values
 */

/**
 * Extracts raw data from every Archi element according to `modelMap`.
 *
 * @param {ModelMap} modelMap
 * @returns {Object[]} Array of objects, each with keys from `modelMap` (and `others`)
 * @throws {TypeError} on invalid inputs
 */
function getModelData(modelMap) {
  if (!dataUtils.isObject(modelMap)) {
    throw new TypeError('getModelData(): modelMap must be an object');
  }
  const {
    conceptName,
    conceptType,
    conceptID,
    conceptDocument,
    conceptProperties,
    relationshipTypes,
    others
  } = modelMap;
  // Validate required map fields
  if (typeof conceptName !== 'string' ||
      typeof conceptType !== 'string' ||
      typeof conceptDocument !== 'string' ||
      typeof conceptID   !== 'string') {
    throw new TypeError(
      'getModelData(): conceptName, conceptType, conceptDocument, conceptID must be strings'
    );
  }
  if (
    !Array.isArray(conceptProperties) ||
    !Array.isArray(relationshipTypes)
  ) {
    throw new TypeError(
      'getModelData(): conceptProperties and relationshipTypes must be arrays'
    );
  }

  log.info(`getModelData(): extracting ${conceptProperties.length} props and ${relationshipTypes.length} rel types`);
  log.debug('modelMap:', JSON.stringify(modelMap));

  // Grab all elements
  const elems = toJsArray($('element').toArray());
  log.info(`Found ${elems.length} elements in model`);

  // Pre-fetch all relationships
  const rels = toJsArray($('relationship').toArray());

  // Build raw data objects
  const data = elems.map(el => {
    const obj = {};
    // 1) Basic fields
    obj[conceptName] = el.name || '';
    // obj[conceptType] = (el.type && el.type.name) || '';
    obj[conceptType] = el.type  || '';
    obj[conceptDocument] = el.documentation || '';
    obj[conceptID]   = el.id || '';

    // 2) Element properties
    conceptProperties.forEach(propKey => {
      obj[propKey] = (el.prop(propKey) || '').toString();
    });

    // 3) Outgoing relationships by type
    relationshipTypes.forEach(relType => {
      const targets = rels
        .filter(r =>
          r.type && r.type.name === relType &&
          r.source && r.source.id === el.id
        )
        .map(r => (r.target && r.target.id) || '');
      obj[relType] = targets.join(',');
    });

    // 4) Any other custom functions
    if (dataUtils.isObject(others)) {
      Object.entries(others).forEach(([key, fn]) => {
        if (typeof fn === 'function') {
          try {
            obj[key] = fn(el);
          }
          catch (err) {
            log.error(`getModelData: error in others["${key}"] for element ${el.id}: ${err}`);
            obj[key] = '';
          }
        }
      });
    }

    return obj;
  });

  // Preview first five
  log.debug(
    'getModelData() preview:\n' +
    data.slice(0,5)
      .map((rec, i) => `#${i+1} ${JSON.stringify(rec, null, 2)}`)
      .join('\n\n')
  );

  return data;
}

/**
 * Maps an array of raw modelData objects into record objects keyed by propKeys.
 *
 * @param {Object[]} modelData  Output from getModelData()
 * @param {string[]} propKeys   Desired output keys
 * @returns {Object[]}          Array of records with only propKeys present
 * @throws {TypeError} on invalid inputs
 */
function mapModelDataToRecords(modelData, propKeys) {
  if (!Array.isArray(modelData)) {
    throw new TypeError('mapModelDataToRecords(): modelData must be an array');
  }
  if (!Array.isArray(propKeys)) {
    throw new TypeError('mapModelDataToRecords(): propKeys must be an array');
  }

  log.info(`mapModelDataToRecords(): mapping to ${propKeys.length} keys`);
  log.debug('propKeys:', JSON.stringify(propKeys));

  const records = modelData.map((item, idx) => {
    if (!dataUtils.isObject(item)) {
      log.error(`mapModelDataToRecords: skipping non-object at index ${idx}`);
      return null;
    }
    const rec = {};
    propKeys.forEach(key => {
      const v = item[key];
      rec[key] = v != null ? v.toString() : '';
    });
    return rec;
  }).filter(r => r !== null);

  // Preview first five
  log.debug(
    'mapModelDataToRecords() preview:\n' +
    records.slice(0,5)
      .map((r,i) => `#${i+1} ${JSON.stringify(r, null, 2)}`)
      .join('\n\n')
  );

  return records;
}

/**
 * Extracts **all** Archi elements into ModelEntry[].
 *
 * @param {string[]} propKeys
 *   List of all property keys (columns) expected downstream.
 * @returns {{ el: IElement, row: Object, sheetRow: number }[]}
 */
function getModelBlankEntries(propKeys) {
  if (!Array.isArray(propKeys)) {
    throw new TypeError('getModelEntries(): propKeys must be an array of strings');
  }
  log.info(`getModelEntries(): extracting ${propKeys.length} columns for every model element`);

  const allElems = toJsArray($('element').toArray());
  log.info(`Total elements in model: ${allElems.length}`);

  // build {el, row, sheetRow} for each element
  const entries = allElems.map((el, i) => {
    const row = {};
    propKeys.forEach(key => { row[key] = ''; });
    return { el, row, sheetRow: i + 1 };
  });

  log.debug(
    'getModelEntries() preview:\n' +
    entries.slice(0,5)
      .map(({ sheetRow, row }, ix) =>
        `#${ix+1} (sheetRow=${sheetRow}): ${JSON.stringify(row)}`
      ).join('\n')
  );

  return entries;
}

module.exports = {
  
};


module.exports = {
  getModelData,
  mapModelDataToRecords,
  getModelBlankEntries
};
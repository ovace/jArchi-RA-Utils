/**
 * common-utils.ajs
 * Common utility functions for jArchi scripts.
 *
 * Dependencies:
 *   - Console API (console.clear/show/log/error)
 *   - Java interoperability for File I/O and list conversion.
 */

// Load shared libraries
  const libPath = __DIR__ + '.\\';  
  const logger = require(libPath + 'logger.ajs');
  const XLSX   = require(libPath + 'xlsx.full.min.js');

  const { log, 
          debug, 
          warn, 
          error 
        } = logger;

/**
 * Prompt the user to select a file or directory.
 * @param {string} title - Dialog title.
 * @param {Object[]} filters - Array of filter objects for file dialog.
 * @param {Function} promptFn - window.promptOpenFile or window.promptOpenDirectory
 * @returns {string|null} Selected path or null if cancelled.
 */
function promptForFile(title="Select File", filters, promptFn) {
    try {
        const path = promptFn({ title, filters });
        return path;
    } catch (e) {
        console.error("[ERROR] promptForFile: " + e);
        return null;
    }
}

/**
 * Convert a Java list or array-like to a native JS array.
 * @param {JavaList|Array} list
 * @returns {any[]} Native JS array.
 */
function toJsArray(list) {
    if (list == null) throw new Error('toJsArray(): input is null or undefined');
    return Array.isArray(list) ? list : Java.from(list);
}

/**
 * Build a CSV header line from a list of column keys.
 * @param {string[]} baseHeaders
 * @returns {string} CSV header line.
 */
function buildHeader(baseHeaders) {
    const hdrs = toJsArray(baseHeaders);
    return hdrs.join(',');
}

/**
 * Build one CSV line for a record object.
 * @param {Object} record - Key/value map for a row.
 * @param {string[]} baseHeaders - List of header keys in order.
 * @returns {string} Quoted CSV row.
 */
function buildCsvLine(record, baseHeaders) {
    const hdrs = toJsArray(baseHeaders);
    return hdrs.map(h => {
        let val = record[h];
        if (val === undefined || val === null) val = '';
        const escaped = String(val).replace(/"/g, '""');
        return `"${escaped}"`;
    }).join(',');
}

// /** Build one CSV line for a merged record object. */
// function buildCsvLine(elem, baseHeaders) {
// const hdrs = toJsArray(baseHeaders);
// const fields = [];
// hdrs.forEach(function(key) {
//     let raw = elem[key] != null ? elem[key] : '';
//     if (Array.isArray(raw)) raw = formatForCSV(raw);
//     if (typeof raw === 'string') raw = '"' + raw.replace(/"/g,'""') + '"';
//     fields.push(raw);
// });
// if debug('buildCsvLine: id=' + (elem._id||elem.ID) + ', inView=' + elem.inView);
// return fields.join(',');
// }


/**
 * Normalize a string for case/whitespace-insensitive matching.
 * @param {string} input
 * @returns {string}
 */
function normalize(input) {
    return input.toString().replace(/\s+/g, ' ').trim().toLowerCase();
}

/**
   * Write CSV data (string or array) to disk.
   * @param {string[]|java.util.List|string} lines
   * @param {string} outputPath
   */
function writeCsv(lines, outputPath) {
if (lines == null) throw new Error('writeCsv(): no data provided');
const all = (typeof lines === 'string')
    ? lines.split('\n')
    : toJsArray(lines);
debug('[DEBUG] writeCsv: writing ' + all.length + ' lines → ' + outputPath);    

const File       = Java.type('java.io.File');
const FileWriter = Java.type('java.io.FileWriter');
const writer     = new FileWriter(new File(outputPath));
try {
    writer.write(all.join('\n'));
} finally {
    writer.close();
}
}

function readCSV(filePath,delimiter){
    var Paths=Java.type("java.nio.file.Paths"),Files=Java.type("java.nio.file.Files");
    var csv=new java.lang.String(Files.readAllBytes(Paths.get(filePath)),"UTF-8");
    var lines=csv.replace(/\r/g,'').split('\n').filter(Boolean);
    var headers=lines[CONFIG.headerRowIndex].split(delimiter).map(function(s){return s.trim();});
    var data=lines.slice(CONFIG.headerRowIndex+1).map(function(line){
        var fields=line.split(delimiter),row={};
        headers.forEach(function(h,idx){row[h]=(fields[idx]||"").trim();});
        return row;
    });
    debug("Parsed "+data.length+" rows from CSV");
    debug("Headers: "+headers.join(", "));
    return{headers:headers,data:data};
}

function getRowValue(row, key) {
    if (!row) {
        debug(`[DEBUG] getRowValue: Row is undefined for key '${key}'`);
        return undefined;
    }
    if (row[key] !== undefined) {
        debug(`[DEBUG] getRowValue: Found exact match for key '${key}' with value '${row[key]}'`);
        return row[key];
    }
    var lkey = key.toLowerCase().replace(/[\s_]/g, "");
    for (var k in row) {
        if (k && k.toLowerCase().replace(/[\s_]/g, "") === lkey) {
            debug(`[DEBUG] getRowValue: Matched key '${key}' to column '${k}' with value '${row[k]}'`);
            return row[k];
        }
    }
    debug(`[DEBUG] getRowValue: No match found for key '${key}'`);
    return undefined;
}

function getActiveModel(){
    if(typeof model==="undefined"||!model)throw new Error("No active model found.");
    log("Using model: "+model.name);
    return model;
}

/**
 * Escape all special characters in `input` by replacing them
 * with their corresponding tokens from CONFIG.escapeMap.
 *
 * @param {string} input
 * @returns {string} The escaped string.
 */
function escapeString(input) {
  if (typeof input !== "string") {
    return input;
  }

  let result = input;
  // For each token → char mapping, replace char with token
  Object.entries(CONFIG.escapeMap).forEach(([token, char]) => {
    // Split/join avoids regex pitfalls with control chars
    result = result.split(char).join(token);
  });

  return result;
}

/**
 * Un‐escape all tokens in `input` by replacing them
 * with their corresponding characters from CONFIG.escapeMap.
 *
 * @param {string} input
 * @returns {string} The unescaped string.
 */
function unescapeString(input) {
  if (typeof input !== "string") {
    return input;
  }

  let result = input;
  // For each token → char mapping, replace token with char
  Object.entries(CONFIG.escapeMap).forEach(([token, char]) => {
    result = result.split(token).join(char);
  });

  return result;
}

/**
 * Escape folder names containing special characters or spaces for use in selector.
 * Wraps names with quotes and escapes embedded quotes.
 * 
 * @param {string} name
 * @returns {string} escaped name suitable for JArchi selector
 */
function escapeFolderName(name) {
    var escaped = name.replace(/"/g, '\\"');
    return '"' + escaped + '"';
}

/**
 * Normalizes a folder name by stripping all non-alphanumeric characters.
 * @param {string} name
 * @returns {string} Normalized folder name
 */
function normalizeFolderName(name) {
    if (!name) return "";
    return String(name).replace(/[^a-zA-Z0-9]/g, "");
}

/**
 * Gets all root folders in the model as an array, and also builds a map by name.
 * Uses jArchi idiom for maximum compatibility. Logs each folder.
 *
 * @param {object} model - The ArchiMate model object
 * @returns {{ array: object[], map: object }}
 *   - array: JS array of root folder objects
 *   - map: JS object, name → folder
 */
function getRootFolders(model) {
    if (!model) {
        error("[ERROR] getRootFolders: model is undefined.");
        return { array: [], map: {} };
    }
    // Use jArchi idiom: get all direct child folders of the model
    const rootFoldersArr = $(model).children('folder').toArray();
    if (rootFoldersArr.length === 0) {
        log("[WARN] getRootFolders: No root folders found in the model.");
    } else {
        debug("[DEBUG] Root folders (names): " + rootFoldersArr.map(f => f.name).join(", "));
    }
    // Build a map by name for quick lookup
    const rootFoldersByName = {};
    rootFoldersArr.forEach(function(folder) {
        rootFoldersByName[folder.name] = folder;
        debug(`[DEBUG] [getRootFolders] Mapped root folder: '${folder.name}'`);
    });
    return { array: rootFoldersArr, map: rootFoldersByName };
}

/**
 * Gets all immediate subfolders of a folder as a JS array.
 * Logs found subfolders.
 *
 * @param {object} folder - Parent folder object
 * @returns {object[]} Array of subfolder objects
 */
function getSubfolders(folder) {
    if (!folder) {
        error("[ERROR] getSubfolders: parent folder is undefined.");
        return [];
    }
    const subfolders = $(folder).children('folder').toArray();
    debug(`[DEBUG] [getSubfolders] Folder '${folder.name}' has subfolders: [${subfolders.map(f => f.name).join(", ")}]`);
    return subfolders;
}

/**
 * Find the first folder with the given name using JArchi selector syntax.
 * Logs the result to the console.
 * 
 * @param {string} folderName - The folder name to find.
 * @returns {Object|null} The folder object if found, otherwise null.
 */
function findFolderByName_selector(folderName) {
    var escapedName = escapeFolderName(folderName);
    var folderCollection = $("folder." + escapedName).first();

    if (folderCollection && folderCollection.size() > 0) {
        var folder = folderCollection.get(0);
        debug("Found folder (selector): " + folder.name + " (id: " + folder.id + ")");
        return folder;
    } else {
        debug("No folder found with name '" + folderName + "' (selector).");
        return null;
    }
}

/**
 * Find all folders with the given name using filter(function).
 * Logs results to the console.
 * 
 * @param {string} folderName - The exact folder name to match.
 * @returns {Collection} JArchi collection of folders matching the name (empty if none).
 */
function findFoldersByName_filter(folderName) {
    var folders = $("folder").filter(function(f) {
        return f.name === folderName;
    });

    if (folders && folders.size() > 0) {
        debug("Found " + folders.size() + " folder(s) (filter):");
        folders.each(function(folder) {
            debug("  - " + folder.name + " (id: " + folder.id + ")");
        });
    } else {
        debug("No folder found with name '" + folderName + "' (filter).");
    }

    return folders;
}

/**
 * Find the first subfolder with the given name under a specified parent folder.
 * Logs the result to the console.
 * 
 * @param {Object} parentFolderObj - JArchi folder object under which to search.
 * @param {string} subFolderName - The name of the subfolder to find.
 * @returns {Object|null} The subfolder object if found, else null.
 */
function findSubFolderByName(parentFolderObj, subFolderName) {
    if (!parentFolderObj) {
        debug("Parent folder object is null or undefined.");
        return null;
    }

    var escapedName = escapeFolderName(subFolderName);
    // Get immediate children folders matching the subFolderName selector
    // Use .children("folder.<name>") to find direct subfolders with the name
    var matchingSubFolders = parentFolderObj.children("folder." + escapedName).first();

    if (matchingSubFolders && matchingSubFolders.size() > 0) {
        var subFolder = matchingSubFolders.get(0);
        debug("Found subfolder: " + subFolder.name + " (id: " + subFolder.id + ") under parent folder: " + parentFolderObj.name);
        return subFolder;
    } else {
        debug("No subfolder named '" + subFolderName + "' found under parent folder: " + parentFolderObj.name);
        return null;
    }
}

/**
 * Find all subfolders with a given name under a specified parent folder name.
 * Logs results to the console.
 * 
 * @param {string} parentFolderName - Name of the parent folder to search within.
 * @param {string} subFolderName - Name of the subfolder(s) to find under the parent.
 * @returns {Collection} JArchi collection of matching subfolders (empty if none).
 */
function findSubfoldersUnderParent(parentFolderName, subFolderName) {
    // Find all parent folders matching parentFolderName
    var parents = $("folder").filter(function(f) {
        return f.name === parentFolderName;
    });

    if (!parents || parents.size() === 0) {
        debug("Parent folder '" + parentFolderName + "' not found.");
        return $();  // empty collection
    }

    var matchedSubfolders = $(); // empty collection to accumulate results

    parents.each(function(parent) {
        // Get immediate children of this parent folder that are folders
        var childrenFolders = parent.children("folder");

        // Filter children by subFolderName
        var filtered = childrenFolders.filter(function(f) {
            return f.name === subFolderName;
        });

        // Accumulate matching subfolders
        matchedSubfolders = matchedSubfolders.add(filtered);
    });

    if (matchedSubfolders.size() > 0) {
        debug("Found " + matchedSubfolders.size() + " subfolder(s) named '" + subFolderName +
                    "' under parent folder '" + parentFolderName + "':");
        matchedSubfolders.each(function(f) {
            debug("  - " + f.name + " (id: " + f.id + ")");
        });
    } else {
        debug("No subfolders named '" + subFolderName + "' found under parent folder '" +
                    parentFolderName + "'.");
    }

    return matchedSubfolders;
}

/**
 * Find all subfolders with a given name under a specified parent folder object.
 * Logs results to the console.
 * 
 * @param {Object} parentFolder - JArchi Folder object to search within.
 * @param {string} subFolderName - Name of the subfolder(s) to find under the parent.
 * @returns {Collection} JArchi collection of matching subfolders (empty if none).
 */
function getImmediateChildFolders(parentFolder) {
    if (!parentFolder || parentFolder.type !== "folder") {
        debug("Invalid parentFolder provided. It must be a JArchi Folder object.");
        return $();  // empty collection
    }

    var allFolders = $("folder");

    var children = allFolders.filter(function(f) {
        return f.parent != null && f.parent.id === parentFolder.id;
    });

    return children;
}
function findSubfoldersUnderParentObject(parentFolder, subFolderName) {
    if (!parentFolder || parentFolder.type !== "folder") {
        debug("Invalid parentFolder provided. It must be a JArchi Folder object.");
        return $();  // empty collection
    }
    
    if (typeof subFolderName !== "string" || subFolderName.trim() === "") {
        debug("Invalid subFolderName provided. It must be a non-empty string.");
        return $();  // empty collection
    }

    // Get immediate child folders of the parent folder
    var childrenFolders = getImmediateChildFolders(parentFolder);

    // Filter children by name
    var matchedSubfolders = childrenFolders.filter(function(f) {
        return f.name === subFolderName;
    });

    if (matchedSubfolders.size() > 0) {
        debug("Found " + matchedSubfolders.size() + " subfolder(s) named '" + subFolderName +
                    "' under parent folder '" + parentFolder.name + "':");
        matchedSubfolders.each(function(f) {
            debug("  - " + f.name + " (id: " + f.id + ")");
        });
    } else {
        debug("No subfolders named '" + subFolderName + "' found under parent folder '" +
                    parentFolder.name + "'.");
    }
    debug("Found " + matchedSubfolders + " of Type: " + matchedSubfolders.type +" subfolder(s) named '" + subFolderName +
                "' under parent folder '" + parentFolder.name + "':");
    return matchedSubfolders;
}

/**
 * Create a subfolder with the specified name under the given parent folder object.
 * Performs safety checks and logs actions and failures.
 * 
 * @param {Object} parentFolderObj - JArchi Folder object under which to create the subfolder.
 * @param {string} subFolderName - Name of the subfolder to create.
 * @returns {Object|null} The newly created subfolder object, or null if creation failed.
 */
function createSubfolderUnderParent(parentFolderObj, subFolderName) {
    if (!parentFolderObj) {
        debug("Error: parentFolderObj is null or undefined. Cannot create subfolder.");
        return null;
    }

    if (typeof subFolderName !== "string" || subFolderName.trim() === "") {
        debug("Error: subFolderName must be a non-empty string.");
        return null;
    }

    if (parentFolderObj.type !== "folder") {
        debug("Error: The parentFolderObj is not a folder (type = '" + parentFolderObj.type + "').");
        return null;
    }

    // Get all folders in the model
    var allFolders = $("folder");

    // Filter to find existing subfolders with the same name under parentFolderObj
    var existingSubfolders = allFolders.filter(function(f) {
        return f.parent != null && f.parent.id === parentFolderObj.id && f.name === subFolderName;
    });

    if (existingSubfolders && existingSubfolders.size() > 0) {
        debug("Subfolder '" + subFolderName + "' already exists under parent folder '" + parentFolderObj.name + "'.");
        return existingSubfolders.get(0);  // Return the existing subfolder object
    }

    try {
        // Create the subfolder under the parent folder
        var newSubfolder = parentFolderObj.createFolder(subFolderName);

        if (newSubfolder && newSubfolder.type === "folder") {
            debug("Successfully created subfolder '" + subFolderName + "' under parent folder '" + parentFolderObj.name + "'.");
            return newSubfolder;
        } else {
            debug("Failed to create subfolder '" + subFolderName + "'. The returned object is invalid.");
            return null;
        }
    } catch (e) {
        debug("Exception while creating subfolder: " + e.message);
        return null;
    }
}

function getOrCreateSubfolder(parentFolder,subfolderName){     
    
    var pf = findFoldersByName_filter(parentFolder).first();
    if(!pf)throw new Error("Could not find parent folder: "+parentFolder);
    else log("Found parent folder: "+parentFolder+ " Type: "+pf.type);
    
    debug("searching for sub folder: " + subfolderName);
    var subfolder=findSubfoldersUnderParentObject(pf,subfolderName);

    if(subfolder.size()==0){
        log("Creating subfolder '"+ subfolderName +"'");
        subfolder=createSubfolderUnderParent(pf, subfolderName);
        if(!subfolder)throw new Error("Could not create subfolder: "+subfolderName);
    }else{
        log("Found subfolder '"+ subfolder.first().name + "'");
    }
    return subfolder;
}

/** Load the SheetJS (xlsx) library */
function loadSheetJS(path) {
try {
    return require(path);
} catch (e) {
    throw new Error('Cannot load SheetJS: ' + e);
}
}

/**
 * Read a file into a Base64 string using Java NIO + Base64.
 * @param {string} filePath
 * @returns {string}
 */
function readFileBase64(filePath) {
try {
    const Paths  = Java.type('java.nio.file.Paths');
    const Files  = Java.type('java.nio.file.Files');
    const Base64 = Java.type('java.util.Base64');
    const bytes = Files.readAllBytes(Paths.get(filePath));
    const encoded = Base64.getEncoder().encodeToString(bytes);
    debug('[DEBUG] readFileBase64: ' + bytes.length + ' bytes → ' + encoded.length + ' chars');
    return encoded;
} catch (e) {
    console.error('[ERROR] readFileBase64 failed: ' + e);
    throw new Error('Cannot read file: ' + e);
}
}

/** Ensure all required headers exist in the sheet */
function validateColumns(colIdxFn, required) {
required.forEach(c => {
    if (colIdxFn(c) < 0) {
    throw new Error('Missing required column "' + c + '"');
    }
});
}

/**
 * Checks which ArchiMate view(s) contain the given element by scanning each view’s diagram objects.
 * Uses view.find() to retrieve all visual objects in each view and matches on .concept.id
 * @param {EObjectProxy} elem
 * @returns {string|string[]} view name, array of names, or "Orphan"
 *
 * Each visual object (.find()) has a .concept property linking back to the model element fileciteturn4file17.
 */
function getElementViews(elem) {
const viewNames = [];
// Iterate all views in the model
const allViews = toJsArray($('view').toArray());
allViews.forEach(view => {
    // Retrieve all visual objects in this view
    const allObjects = toJsArray($(view).find().toArray());
    // Check if any object represents our element
    for (let obj of allObjects) {
    if (obj.concept && obj.concept.id === elem.id) {
        viewNames.push(view.name);
        break;
    }
    }
});
debug('[DEBUG] getElementViews(' + elem.id + '): ' + viewNames);
if (!viewNames.length) return 'Orphan';
return viewNames.length === 1 ? viewNames[0] : viewNames;
}

/**
 * Get values of custom properties for an element.
 * @param {Object} el
 * @param {Array<string>} keys
 * @returns {Array<any>}
 */
function collectPropValues(el, keys) {
const props = el.properties ? el.properties() : {};
return keys.map(k => props.hasOwnProperty(k) ? el.prop(k) : '');
}

/** Flatten an array into a semicolon-delimited string, or pass through. */
function formatForCSV(v) {
return Array.isArray(v) ? v.join(';') : v;
}

module.exports = { 
    buildCsvLine,    
    buildHeader,    
    collectPropValues,
    createSubfolderUnderParent,
    escapeFolderName,
    escapeString,
    findFolderByName_selector,
    findFoldersByName_filter,
    findSubFolderByName,
    findSubfoldersUnderParent,
    findSubfoldersUnderParentObject,
    formatForCSV,
    getActiveModel,
    getElementViews,
    getImmediateChildFolders,
    getOrCreateSubfolder,
    getRootFolders,
    getRowValue,
    getSubfolders,
    loadSheetJS,
    normalize,
    normalizeFolderName,
    promptForFile,
    readCSV,
    readFileBase64,
    toJsArray,   
    unescapeString,
    validateColumns,
    writeCsv,
};


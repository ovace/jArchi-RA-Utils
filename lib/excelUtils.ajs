/**
 * ./lib/excelUtils.ajs
 *
 * Reusable loader/validator for Excel sheets via SheetJS.
 */

const File    = Java.type("java.io.File");

// 1. Load environment from parent folder’s .env
const parentDir = new File(__DIR__.replace(/[\\/]+$/, "")).getParent() + File.separator;
var env = load(__DIR__ + "loadEnv.ajs").loadEnv(parentDir + ".env");

const log     = require(__DIR__ + "logger.ajs").log;
const common  = require(__DIR__ + "common_utils.ajs");
const dataUtils = require(__DIR__ + "data_utils.ajs");


// // 2. Load the SheetJS bundle so that global `XLSX` is available
const XLSX = require(__DIR__ + "xlsx.full.min.js");

// ————————————————————————————————————————————————————————————————————————————————
// Load SheetJS if needed (adjust SHEETJS_PATH in your .env)
// if (typeof XLSX === 'undefined') {
//     // var env = require('./loadEnv').loadEnv();
//     // Strip any surrounding quotes from the path
//     var rawPath = env.SHEETJS_PATH;
//     var sheetjsPath = rawPath.replace(/^['"]|['"]$/g, '');
//     var sheetjsUri = java.nio.file.Paths
//           .get(sheetjsPath)
//           .toUri()
//           .toString();
//     load(sheetjsUri);  // brings in global XLSX
// }

// core imports
const javaBase64   = java.util.Base64;
const fileWr       = java.nio.file.Files;
const filePathUtil = java.nio.file.Paths;
const path = java.nio.file.Paths;
const fs   = java.nio.file.Files;
const { promptForFile } = common;  // >>> new import

// simple in-memory cache keyed by "filePath|sheetName"
var _excelCache = {};

/**
 * >>> NEW
 * Ensure the given path exists and has an Excel extension.
 * If not, prompt the user to pick one via a file dialog.
 *
 * @param {string} filePath
 * @returns {string} a valid Excel file path
 * @throws {Error} if user cancels selection
 */
function ensureExcelFile(filePath) {
    var p       = path.get(filePath || "");
    var exists  = fs.exists(p);
    var isExcel = typeof filePath === 'string' && filePath.match(/\.(xlsx|xls)$/i);

    if (!exists || !isExcel) {
        log.warn(`Invalid or missing Excel file: "${filePath}"`);
        // promptForFile(title, [extensions])
        var chosen = promptForFile("Select an Excel file", ["xlsx", "xls"], window.promptOpenFile);
        if (!chosen) {
            log.error("Excel file selection cancelled by user.");
            throw new Error("Excel file selection required");
        }
        log.info(`User selected Excel file: ${chosen}`);
        return chosen;
    }
    return filePath;
}

/**
 * >>> NEW
 * Validate that the sheet’s header row contains all required columns.
 *
 * @param {Array<Object>} rows             – array of row-objects
 * @param {Array<string>} requiredHeaders  – list of header names to check
 * @throws {Error} if any required header is missing
 */
function validateHeaders(rows, requiredHeaders) {
    if (!Array.isArray(rows) || rows.length === 0) {
        log.warn("No rows available to validate headers against.");
        return;
    }
    var available = Object.keys(rows[0]);
    var missing   = requiredHeaders.filter(h => available.indexOf(h) === -1);

    if (missing.length) {
        log.error(`Missing required headers: ${missing.join(', ')}`);
        throw new Error(`Required headers not found: ${missing.join(', ')}`);
    }
    log.info("All required headers present.");
}

/**
 * Read an Excel file into either an object keyed by a column or a flat array.
 *
 * @param {Object} opts
 * @param {string} opts.filePath         – Absolute path to the .xlsx/.xls file
 * @param {string} [opts.sheetName]      – Sheet to read; defaults to first
 * @param {string} opts.keyHeader        – Column header whose values become object keys
 * @param {"object"|"array"} [opts.outputType="object"]
 *                                        – "object" → { key: rowObj, … }
 *                                        – "array"  → [rowObj, …]
 * @param {Array<string>} [opts.requiredHeaders]
 *                                        – list of headers to validate after read
 * @returns {Object|Array<Object>}
 * @throws {Error} on I/O, parse, missing header, or validation failure
 */
function loadExcelData({
    filePath,
    sheetName,
    keyHeader,
    outputType,
    requiredHeaders    // >>> new optional param
}) {
    outputType = outputType === 'array' ? 'array' : 'object';

    // >>> ensure valid file or prompt user
    filePath = ensureExcelFile(filePath);

    var cacheKey = filePath + '|' + (sheetName || '<first>');
    if (_excelCache[cacheKey] && _excelCache[cacheKey][outputType]) {
        log.debug(`Cache hit: ${cacheKey} [${outputType}]`);
        return _excelCache[cacheKey][outputType];
    }

    log.info(`Loading Excel file: ${filePath}`);
    var bytes, workbook;
    try {
        bytes    = fs.readAllBytes(path.get(filePath));
        var b64  = java.util.Base64.getEncoder().encodeToString(bytes);
        workbook = XLSX.read(b64, { type: 'base64' });
    }
    catch (ioErr) {
        log.error(`Failed to read or parse Excel file: ${ioErr}`);
        throw ioErr;
    }

    // choose sheet
    var sheets    = workbook.SheetNames;
    if (!sheets.length) {
        throw new Error("Workbook contains no sheets");
    }
    var targetName = (sheetName && sheets.includes(sheetName))
                   ? sheetName
                   : sheets[0];
    if (sheetName && targetName !== sheetName) {
        log.warn(`Sheet "${sheetName}" not found, using "${targetName}"`);
    }
    log.debug(`Using sheet: ${targetName}`);

    // parse to row-objects
    var sheet = workbook.Sheets[targetName];
    var rows  = XLSX.utils.sheet_to_json(sheet, { defval: null });
    log.info(`Parsed ${rows.length} rows from "${targetName}"`);

    // basic header check for keyHeader
    if (!rows.length || !(keyHeader in rows[0])) {
        throw new Error(`Key header "${keyHeader}" not found`);
    }

    // >>> additional header validation step
    if (Array.isArray(requiredHeaders) && requiredHeaders.length) {
        validateHeaders(rows, requiredHeaders);
    }

    // build outputs
    var asArray  = rows;
    var asObject = {};
    for (var rec of rows) {
        var key = rec[keyHeader];
        if (key == null) {
            log.warn(`Row missing key "${keyHeader}", skipping`);
            continue;
        }
        if (outputType === 'object') {
            if (asObject[key] !== undefined) {
                log.warn(`Duplicate key "${key}" – overwriting`);
            }
            asObject[key] = rec;
        }
    }

    // cache & return
    _excelCache[cacheKey] = { object: asObject, array: asArray };
    return outputType === 'array' ? asArray : asObject;
}

/**
 * Loads an Excel sheet, converts it to JS objects, applies extensions,
 * validates presence of required columns, and logs rich diagnostics.
 *
 * @param {string}       excelPath        Absolute path to the .xlsx/.xlsm file
 * @param {ExcelOptions} opts
 * @returns {Object[]}   Array of row‐objects keyed by header
 * @throws {Error}       On missing sheet, missing columns, or mis‐loaded XLSX
 */
function loadAndPrepareSheet(excelPath, opts) {
  const { sheetName, extHeadersMap, requiredColumns } = opts || {};

  // ---- Parameter validation ----
  if (typeof excelPath !== "string" || !excelPath) {
    throw new TypeError("loadAndPrepareSheet: excelPath must be a non-empty string");
  }
  if (typeof sheetName !== "string" || !sheetName) {
    throw new TypeError("loadAndPrepareSheet: sheetName is required");
  }
  if (!dataUtils.isObject(extHeadersMap)) {
    throw new TypeError("loadAndPrepareSheet: extHeadersMap must be an object");
  }
  if (!Array.isArray(requiredColumns)) {
    throw new TypeError("loadAndPrepareSheet: requiredColumns must be an array");
  }

  log.debug(`Loading workbook from: ${excelPath}`);

  // ---- Ensure XLSX is loaded ----
  if (typeof XLSX !== "object" || typeof XLSX.read !== "function") {
    log.error("SheetJS (XLSX) is not loaded or missing .read()");
    throw new Error("SheetJS not available (did you load xlsx.full.min.js?)");
  }

  // ---- 1) Read workbook ----
  const wbData = common.readFileBase64(excelPath);
  const wb     = XLSX.read(wbData, { type: "base64" });
  log.debug(`Workbook contains sheets: ${wb.SheetNames.join(", ")}`);

  // ---- 2) Select worksheet ----
  const sheet = wb.Sheets[sheetName];
  if (!sheet) {
    log.error(`Sheet "${sheetName}" not found in workbook`);
    throw new Error(`Sheet "${sheetName}" not found`);
  }
  log.debug(`Reading sheet "${sheetName}"`);

  // ---- 3) Extract raw rows (to get headers) ----
  const rawRows = XLSX.utils.sheet_to_json(sheet, { header: 1, raw: false });
  if (rawRows.length < 2) {
    log.error("Expected at least 2 rows (title + header)");
    throw new Error("Insufficient rows for header extraction");
  }

  // ---- 4) Trim headers from second Excel row ----
  const headers = rawRows[1].map(cell => cell != null ? cell.toString().trim() : "");
  if (!headers.length) {
    throw new Error("No headers found in row 2");
  }
  log.debug("Extracted headers:", JSON.stringify(headers));

  // ---- 5) Load data rows keyed by those headers ----
  let data = XLSX.utils.sheet_to_json(sheet, {
    header: headers,
    range:  2,      // skip first two rows
    defval: "",     // blank cells → ""
    raw:    false
  });
  log.debug(`Parsed ${data.length} data rows`);

  if (!data.length) {
    log.warn("No data rows found after header; returning empty array");
    return [];
  }

  // ---- 6) Apply external references ----
  data = dataUtils.generateExtRef(data, extHeadersMap);
  log.debug(
    `After generateExtRef: ${data.length} rows, ext map: ${JSON.stringify(extHeadersMap)}`
  );

  // ---- 7) Validate extension headers ----
  const finalHdrs = Object.keys(data[0]).map(h => h.toString().trim());
  const missingExt = Object.values(extHeadersMap)
    .filter(col => !finalHdrs.includes(col));
  if (missingExt.length) {
    log.error("Missing extension columns:", missingExt.join(", "));
    throw new Error(`Missing expected columns: ${missingExt.join(", ")}`);
  }

  // ---- 8) Validate required columns ----
  const idxOf = name => finalHdrs.indexOf(name);
  common.validateColumns(idxOf, requiredColumns);
  log.info("All required columns are present");

  // ---- 9) Preview first five rows ----
  data.slice(0,5).forEach((row, i) => {
    log.debug(`Row ${i+1}: ${JSON.stringify(row, null, 2)}`);
  });

  return data;
}

// /**
//  * Ensure a valid Excel output file path. If none is provided or the extension
//  * isn’t .xlsx/.xls, prompts the user to pick or name one.
//  *
//  * @param {string} filePath
//  * @returns {string} A writable .xlsx or .xls path
//  * @throws {Error} if the user cancels the dialog
//  */
// function ensureOutputFile(filePath) {
//   var isExcel = typeof filePath === 'string' && filePath.match(/\.(xlsx|xls)$/i);
//   if (!isExcel) {
//     log.warn(`Invalid or missing output file: "${filePath}"`);
//     var chosen = promptForFile("Select or name your output Excel file", ["xlsx","xls"], window.promptSaveFile);
//     if (!chosen) {
//       log.error("Output file selection cancelled by user.");
//       throw new Error("Excel output file required");
//     }
//     log.info(`User will write to: ${chosen}`);
//     return chosen;
//   }
//   return filePath;
// }

// /**
//  * Save a JS data object/array to an Excel file.  Uses $JExcel from myexcel.js
//  * to generate the workbook and write it out.
//  *
//  * @param {Object} opts
//  * @param {Array<Object>|Object<string,Object>} opts.data
//  *        The data to save: either an array of row‐records or an object of records (values will be used).
//  * @param {string} opts.outputFile   – Desired output path; will prompt if invalid.
//  * @param {string} [opts.sheetName]  – Sheet name; defaults to 'Sheet1'.
//  * @returns {void}
//  * @throws {Error} on I/O or user cancellation
//  */
// function saveDataToExcel({ data, outputFile, sheetName }) {
//   // normalize output path
//   outputFile = ensureOutputFile(outputFile);

//   // flatten object→array if needed
//   var rows = Array.isArray(data)
//            ? data
//            : Object.keys(data).map(function(k){ return data[k]; });

//   if (rows.length === 0) {
//     log.warn("No data to write; skipping Excel save.");
//     return;
//   }

//   // build header row from first record
//   var headers = Object.keys(rows[0]);

//   log.info(`Writing ${rows.length} rows to Excel: ${outputFile}`);
//   var excel = $JExcel.new();  // from myexcel.js :contentReference[oaicite:0]{index=0}

//   // add or rename sheet
//   var idx = 0;
//   if (sheetName) {
//     idx = excel.addSheet(sheetName);
//   } else {
//     // default sheet0 is already there
//     excel.addSheet("Sheet1");
//     idx = 1;
//   }

//   // write headers (row 0)
//   headers.forEach(function(h, col){
//     excel.set(idx, col, 0, h);
//   });

//   // write data rows
//   rows.forEach(function(rec, row){
//     headers.forEach(function(h, col){
//       var v = rec[h];
//       excel.set(idx, col, row+1, v);
//     });
//   });

//   // write file
//   try {
//     excel.generate(outputFile);
//     log.info(`Excel file saved successfully: ${outputFile}`);
//   }
//   catch (err) {
//     log.error(`Failed to write Excel file: ${err}`);
//     throw err;
//   }
// }


/**
 * Ensure a valid Excel output file path. If none is provided or the extension
 * isn’t .xlsx/.xls, prompts the user to pick or name one.
 *
 * @param {string} filePath
 * @returns {string} A writable .xlsx or .xls path
 * @throws {Error} if the user cancels the dialog
 */
function ensureOutputFile(filePath) {
  var isExcel = typeof filePath === 'string' && filePath.match(/\.(xlsx|xls)$/i);
  if (!isExcel) {
    log.warn(`Invalid or missing output file: "${filePath}"`);
    var chosen = promptForFile("Select or name your output Excel file", ["xlsx","xls"]);
    if (!chosen) {
      log.error("Output file selection cancelled by user.");
      throw new Error("Excel output file required");
    }
    log.info(`User will write to: ${chosen}`);
    return chosen;
  }
  return filePath;
}

/**
 * Save a JS data object/array to an Excel file using SheetJS.
 *
 * @param {Object} opts
 * @param {Array<Object>|Object<string,Object>} opts.data
 *        The data to save: either an array of row‐records or an object of records.
 * @param {string} opts.outputFile   – Desired output path; will prompt if invalid.
 * @param {string} [opts.sheetName]  – Sheet name; defaults to 'Sheet1'.
 * @returns {void}
 * @throws {Error} on I/O or user cancellation
 */
function saveDataToExcel({ data, outputFile, sheetName }) {
  // 1. Validate / prompt for output path
  outputFile = ensureOutputFile(outputFile);

  // 2. Flatten object → array if necessary
  var rows = Array.isArray(data)
           ? data
           : Object.keys(data).map(k => data[k]);

  if (rows.length === 0) {
    log.warn("No data to write; skipping Excel save.");
    return;
  }

  // 3. Build a worksheet from the array of row‐objects
  var headers = Object.keys(rows[0]);
  var ws = XLSX.utils.json_to_sheet(rows, { header: headers });

  // 4. Create a new workbook and append the sheet
  var wb = XLSX.utils.book_new();
  var name = sheetName || "Sheet1";
  XLSX.utils.book_append_sheet(wb, ws, name);

  log.info(`Generating workbook with ${rows.length} rows on sheet "${name}"`);

  // 5. Write workbook to Base64 string
  //    Using bookType 'xlsx' and type 'base64' so we can decode & write manually
  var b64 = XLSX.write(wb, {
    bookType: 'xlsx',
    type:     'base64'
  });

  // 6. Decode Base64 → bytes and write to file
  var bytes      = javaBase64.getDecoder().decode(b64);
  var outPath    = filePathUtil.get(outputFile);
  try {
    fileWr.write(outPath, bytes);
    log.info(`Excel file saved successfully: ${outputFile}`);
  }
  catch (e) {
    log.error(`Failed to write Excel file: ${e}`);
    throw e;
  }
}

// ────────────────────────────────────────────────────────────────────────────────
// export everything, including our new helpers
module.exports = Object.assign(module.exports || {}, {
    loadAndPrepareSheet,
    loadExcelData,
    ensureExcelFile,   // >>> new
    validateHeaders,    // >>> new
    ensureOutputFile,
    saveDataToExcel
});

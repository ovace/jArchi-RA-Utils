/**
 * informationMapExporter.ajs
 *
 * Exports element data to Excel based on:
 *  - `filterGroups` defining mutually‐exclusive element groups
 *  - `informationMap` mapping headers to element‐field specs + group
 *
 * Fully instrumented with debug/info/warn/error logs for traceability.
 *
 * Usage: Run in jArchi (Script → Run Script…).
 */

// ── 1. Console setup ─────────────────────────────────────────────────────────
console.clear();
console.show();

// ── 2. Load ENV and libraries ────────────────────────────────────────────────
const libDir   = __DIR__ + 'lib/';
console.log(`libDir:  ${libDir}`);
const envPath  = __DIR__ + '.env';
console.log(`envPath: ${envPath}`);
const CONFIG   = require(libDir + 'loadEnv.ajs').loadEnv(envPath);

const { log } = require(libDir + 'logger.ajs');
const common   = require(libDir + 'commonUtils.ajs');
const toJsArray = common.toJsArray;

const {
  promptForModel,
  getActiveModel,
  ensureModelLoaded,
  getElementViews,
  conceptRelationshipMap
} = require(libDir + 'modelUtils.ajs');

const { saveDataToExcel } = require(libDir + 'fileUtils.ajs');


// ── 3. JSON / ENV Helpers ───────────────────────────────────────────────────

function parseJsonOrObject(input) {
  log.debug(`[parseJsonOrObject] input type=${typeof input}`);
  if (input && typeof input === 'object') return input;
  let str = String(input||'').trim();
  if (!str) throw new Error('Empty input for JSON parse');
  if (str.startsWith('{') && !str.endsWith('}')) {
    const last = str.lastIndexOf('}');
    str = str.substring(0, last+1);
  }
  str = str.replace(/,(\s*[\]}])/g,'$1');
  try { return JSON.parse(str); }
  catch {
    try { return eval('('+str+')'); }
    catch(e){ log.error(`parseJsonOrObject eval failed: ${e}`); throw e; }
  }
}

function readEnvBlock(key) {
  log.debug(`[readEnvBlock] extracting ${key}`);
  const Files   = Java.type('java.nio.file.Files');
  const Paths   = Java.type('java.nio.file.Paths');
  const content = new java.lang.String(Files.readAllBytes(Paths.get(envPath)),'UTF-8');
  const lines   = content.split(/\r?\n/);
  let capturing=false, depth=0, block=[];
  for(let line of lines){
    if(!capturing){
      const idx=line.indexOf(key+'=');
      if(idx>=0){
        const after=line.substring(idx+key.length+1);
        const bi=after.indexOf('{');
        if(bi>=0){
          capturing=true;
          const rest=after.substring(bi).replace(/^\s*#\s?/,'');
          block.push(rest);
          for(let ch of rest){ if(ch==='{' )depth++; else if(ch==='}')depth--; }
          if(depth===0) break;
        }
      }
    } else {
      const clean=line.replace(/^\s*#\s?/,'');
      block.push(clean);
      for(let ch of clean){ if(ch==='{' )depth++; else if(ch==='}')depth--; }
      if(depth===0) break;
    }
  }
  if(!capturing) { log.warn(`[readEnvBlock] no ${key}`); return null }
  if(depth!==0) log.warn(`[readEnvBlock] braces unbalanced for ${key}`);
  return block.join('\n');
}

function parseEnvBlockOrRaw(key, raw) {
  log.debug(`[parseEnvBlockOrRaw] key=${key}`);
  let str=raw;
  if(typeof str==='string' && !str.trim().endsWith('}')){
    const blk=readEnvBlock(key);
    if(blk) str=blk;
  }
  if(!str) throw new Error(`${key} is required`);
  const obj=parseJsonOrObject(str);
  if(typeof obj!=='object'||Array.isArray(obj)) throw new Error(`Invalid ${key}`);
  log.info(`${key} entries=${Object.keys(obj).length}`);
  return obj;
}


// ── 4. Spec parsing & evaluation ─────────────────────────────────────────────

function parseSpec(specString) {
  log.debug(`[parseSpec] ${specString}`);
  const parts=specString.split(/\s+where\s+/i),
        source=parts[0].trim(),
        filterMap={};
  if(parts[1]){
    parts[1].trim().replace(/^\{|\}$/g,'')
      .split(/\s*,\s*/).forEach(cond=>{
        const [k,v]=cond.split('=').map(s=>s.trim());
        try{ filterMap[k]=eval(v) }
        catch(e){ log.error(`parseSpec filter ${k} eval failed: ${e}`); filterMap[k]=[] }
      });
  }
  const sourceParts=source.split('.').map(s=>s.trim());
  return { source, sourceParts, filterMap };
}

function getValueByPath(ctx, pathParts) {
  return pathParts.reduce((o,k,i)=>{
    const v=(o&&o[k]!=null)?o[k]:null;
    if(v===null&&o!==null) log.debug(`getValueByPath miss ${k}@${i}`);
    return v;
  },ctx);
}

function evaluateSpec(spec,El) {
  const sp=spec.sourceParts.map(p=>p.trim());
  if(sp[0]==='element'&&sp[1]==='relationship') sp.shift();
  // element.*
  if(sp[0]==='element'){
    for(let fk in spec.filterMap){
      const val=getValueByPath({element:El,property:El.Pmap},fk.split('.'));
      if(!spec.filterMap[fk].includes(val)) return null;
    }
    if(sp[1]==='property') return El.Pmap[sp[2]]||'';
    if(sp[1]==='inView') return El.V.map(v=>v.name);
    return El[sp[1]]||'';
  }
  // relationship.out/in.*
  if(sp[0]==='relationship'&&(sp[1]==='out'||sp[1]==='in')){
    const rels=(sp[1]==='out'?El.Ro:El.Ri)||[];
    const filtered=rels.filter(r=>{
      for(let fk in spec.filterMap){
        const fp=fk.split('.');
        const val=(fp[0]==='target')
          ?getValueByPath({target:{type:r.targetType,name:r.targetName}},fp)
          :getValueByPath({relationship:r},fp);
        if(!spec.filterMap[fk].includes(val)) return false;
      }
      return true;
    });
    if(sp[2]==='target'&&sp[3]) return filtered.map(r=>sp[3]==='name'?r.targetName:r.targetType);
    if(['targetName','targetType'].includes(sp[2])) return filtered.map(r=>r[sp[2]]);
    return filtered.map(r=>r[sp[2]]||null);
  }
  log.warn(`evaluateSpec unsupported ${spec.source}`);
  return null;
}


// ── 5. Property Mapping ───────────────────────────────────────────────────────

function buildPropMap(el,propertyKeys){
  log.debug(`buildPropMap el=${el.id}`);
  const map={};
  propertyKeys.forEach(key=>{
    let v=null;
    try{ v=el.prop(key) } catch{}
    if(v==null) try{ v=el.prop(key.toLowerCase()) } catch{}
    if(v==null) try{ v=el.prop(key.toUpperCase()) } catch{}
    map[key]= v!=null ? v.toString() : '';
  });
  return map;
}


// ── 6. Data Cache & Diagnostics ───────────────────────────────────────────────

function getAllElements(){
  log.info('getAllElements');
  return toJsArray($('element').toArray());
}

function getAllElementRelationships(elements){
  log.info('getAllElementRelationships');
  const m=conceptRelationshipMap(elements,'out'),
        hdr=m[0]||[], data=m.slice(1),
        idx={srcId:hdr.indexOf('Source ID'),
             relType:hdr.indexOf('Relationship Type'),
             relId:hdr.indexOf('Relationship ID'),
             tgtName:hdr.indexOf('Target Name'),
             tgtType:hdr.indexOf('Target Type'),
             tgtId:hdr.indexOf('Target ID')};
  const map={};
  data.forEach(r=>{
    const sid=r[idx.srcId];
    if(!sid) return;
    map[sid]=map[sid]||[];
    map[sid].push({
      type:r[idx.relType],
      id:r[idx.relId],
      targetName:r[idx.tgtName],
      targetType:r[idx.tgtType],
      targetId:r[idx.tgtId]
    });
  });
  return map;
}

function getAllElementViews(elements){
  log.info('getAllElementViews');
  const map={};
  elements.forEach(el=>{
    const vs=getElementViews(el)||[];
    map[el.id]=Array.isArray(vs)?vs:[];
  });
  return map;
}

function buildDataCache(propertyKeys){
  log.info('buildDataCache');
  const elements=getAllElements(),
        relsByEl=getAllElementRelationships(elements),
        viewsByEl=getAllElementViews(elements),
        enriched=elements.map(el=>({
          id:el.id,
          name:el.name,
          type:(el.type&&el.type.name)?el.type.name:el.type,
          documentation:el.documentation||'',
          Pmap:buildPropMap(el,propertyKeys),
          Ro:relsByEl[el.id]||[],
          V:viewsByEl[el.id]||[]
        }));
  return {elements,enriched,relsByEl,viewsByEl};
}

function dataCacheDiagnostics({elements,relsByEl,viewsByEl}){
  const totalEl=elements.length,
        totalR=Object.values(relsByEl).reduce((s,a)=>s+a.length,0),
        totalV=Object.values(viewsByEl).reduce((s,a)=>s+a.length,0),
        uniqueV=new Set([].concat(...Object.values(viewsByEl).map(vs=>vs.map(v=>v.id)))).size;
  log.info(`Elements:${totalEl} Rels:${totalR} ViewRefs:${totalV} UniqueViews:${uniqueV}`);
  return {elements,relsByEl,viewsByEl};
}


// ── 7. Parse filterGroups & informationMap ────────────────────────────────────

const filterGroupsRaw   = parseEnvBlockOrRaw('filterGroups',CONFIG.filterGroups);
const informationMapRaw = parseEnvBlockOrRaw('informationMap',CONFIG.informationMap);

/**
 * infoEntries [Good]
 */
const infoEntries = Object.entries(informationMapRaw).map(([hdr,obj])=>{
  let sourceStr,group;
  if(typeof obj==='string'){
    sourceStr=obj;
    group=Object.keys(filterGroupsRaw).find(g=>hdr.startsWith(g))||null;
  } else {
    sourceStr=obj.source;
    group=obj.group===undefined?null:obj.group;
  }
  return {header:hdr,spec:parseSpec(sourceStr),group};
});

/**
 * filterSpecs [Added]
 */
const filterSpecs = Object.entries(filterGroupsRaw).reduce((acc,[grp,def])=>{
  acc[grp]=def.or.map(c=>({
    spec:parseSpec(c.key),
    values:Array.isArray(c.values)?c.values:[c.values]
  }));
  return acc;
},{});

/**
 * normalizeValue [Added]
 */
function normalizeValue(v){
  return String(v||'').toLowerCase().replace(/[\s-]+/g,'');
}

/**
 * evaluateFilterGroup [Changed]
 */
function evaluateFilterGroup(group,El){
  const clauses=filterSpecs[group]||[];
  return clauses.some(({spec,values})=>{
    const out=evaluateSpec(spec,El);
    if(out==null) return false;
    const arr=Array.isArray(out)?out:[out];
    const normOut=arr.map(normalizeValue);
    const normVals=values.map(normalizeValue);
    return normOut.some(o=>normVals.includes(o));
  });
}

/**
 * generateFilteredRecords [Changed]
 */
function generateFilteredRecords(elements){
  const headers=Object.keys(informationMapRaw), recs=[];
  elements.forEach(El=>{
    const matched=Object.keys(filterSpecs).filter(g=>evaluateFilterGroup(g,El));
    if(matched.length===0) return;
    const group=matched[0],rec={};
    infoEntries.filter(e=>e.group===group||e.group===null)
      .forEach(e=>{
        let v=evaluateSpec(e.spec,El);
        if(Array.isArray(v)) v=v.join(', ');
        rec[e.header]=v;
      });
    headers.forEach(h=>{ if(!(h in rec)) rec[h]='' });
    recs.push(rec);
  });
  return recs;
}


// ── 8. Main ───────────────────────────────────────────────────────────────────
try {
  let model=getActiveModel();
  if(!model){
    if(CONFIG.modelName){
      ensureModelLoaded(CONFIG.modelName);
      model=getActiveModel();
    } else {
      const choice=promptForModel('Select model');
      ensureModelLoaded(choice);
      model=getActiveModel();
    }
  }
  // Gather propertyKeys
  const propSet=new Set();
  infoEntries.forEach(e=>{
    const sp=e.spec.sourceParts;
    if(sp[0]==='element'&&sp[1]==='property') propSet.add(sp[2]);
  });
  Object.values(filterSpecs).forEach(clauses=>
    clauses.forEach(({spec})=>{
      const sp=spec.sourceParts;
      if(sp[0]==='element'&&sp[1]==='property') propSet.add(sp[2]);
      Object.keys(spec.filterMap).forEach(fk=>{
        const fp=fk.split('.');
        if(fp[0]==='element'&&fp[1]==='property') propSet.add(fp[2]);
      });
    })
  );
  const propertyKeys=Array.from(propSet);

  const cache=buildDataCache(propertyKeys);
  dataCacheDiagnostics(cache);

  const records=generateFilteredRecords(cache.enriched);
  saveDataToExcel({
    data:records,
    outputFile:CONFIG.excelOutput,
    sheetName:'InformationMap',
    headerList:Object.keys(informationMapRaw)
  });
}
catch(err){
  log.error(`informationMapExporter FAILED → ${err}`);
  throw err;
}
